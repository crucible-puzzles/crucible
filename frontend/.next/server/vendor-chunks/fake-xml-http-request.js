"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/fake-xml-http-request";
exports.ids = ["vendor-chunks/fake-xml-http-request"];
exports.modules = {

/***/ "(rsc)/./node_modules/fake-xml-http-request/src/fake-xml-http-request.js":
/*!*************************************************************************!*\
  !*** ./node_modules/fake-xml-http-request/src/fake-xml-http-request.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n * Minimal Event interface implementation\n *\n * Original implementation by Sven Fuchs: https://gist.github.com/995028\n * Modifications and tests by Christian Johansen.\n *\n * @author Sven Fuchs (svenfuchs@artweb-design.de)\n * @author Christian Johansen (christian@cjohansen.no)\n * @license BSD\n *\n * Copyright (c) 2011 Sven Fuchs, Christian Johansen\n */\n\nvar _Event = function Event(type, bubbles, cancelable, target) {\n  this.type = type;\n  this.bubbles = bubbles;\n  this.cancelable = cancelable;\n  this.target = target;\n};\n\n_Event.prototype = {\n  stopPropagation: function () {},\n  preventDefault: function () {\n    this.defaultPrevented = true;\n  }\n};\n\n/*\n  Used to set the statusText property of an xhr object\n*/\nvar httpStatusCodes = {\n  100: \"Continue\",\n  101: \"Switching Protocols\",\n  200: \"OK\",\n  201: \"Created\",\n  202: \"Accepted\",\n  203: \"Non-Authoritative Information\",\n  204: \"No Content\",\n  205: \"Reset Content\",\n  206: \"Partial Content\",\n  300: \"Multiple Choice\",\n  301: \"Moved Permanently\",\n  302: \"Found\",\n  303: \"See Other\",\n  304: \"Not Modified\",\n  305: \"Use Proxy\",\n  307: \"Temporary Redirect\",\n  400: \"Bad Request\",\n  401: \"Unauthorized\",\n  402: \"Payment Required\",\n  403: \"Forbidden\",\n  404: \"Not Found\",\n  405: \"Method Not Allowed\",\n  406: \"Not Acceptable\",\n  407: \"Proxy Authentication Required\",\n  408: \"Request Timeout\",\n  409: \"Conflict\",\n  410: \"Gone\",\n  411: \"Length Required\",\n  412: \"Precondition Failed\",\n  413: \"Request Entity Too Large\",\n  414: \"Request-URI Too Long\",\n  415: \"Unsupported Media Type\",\n  416: \"Requested Range Not Satisfiable\",\n  417: \"Expectation Failed\",\n  422: \"Unprocessable Entity\",\n  500: \"Internal Server Error\",\n  501: \"Not Implemented\",\n  502: \"Bad Gateway\",\n  503: \"Service Unavailable\",\n  504: \"Gateway Timeout\",\n  505: \"HTTP Version Not Supported\"\n};\n\n\n/*\n  Cross-browser XML parsing. Used to turn\n  XML responses into Document objects\n  Borrowed from JSpec\n*/\nfunction parseXML(text) {\n  var xmlDoc;\n\n  if (typeof DOMParser != \"undefined\") {\n    var parser = new DOMParser();\n    xmlDoc = parser.parseFromString(text, \"text/xml\");\n  } else {\n    xmlDoc = new ActiveXObject(\"Microsoft.XMLDOM\");\n    xmlDoc.async = \"false\";\n    xmlDoc.loadXML(text);\n  }\n\n  return xmlDoc;\n}\n\n/*\n  Without mocking, the native XMLHttpRequest object will throw\n  an error when attempting to set these headers. We match this behavior.\n*/\nvar unsafeHeaders = {\n  \"Accept-Charset\": true,\n  \"Accept-Encoding\": true,\n  \"Connection\": true,\n  \"Content-Length\": true,\n  \"Cookie\": true,\n  \"Cookie2\": true,\n  \"Content-Transfer-Encoding\": true,\n  \"Date\": true,\n  \"Expect\": true,\n  \"Host\": true,\n  \"Keep-Alive\": true,\n  \"Referer\": true,\n  \"TE\": true,\n  \"Trailer\": true,\n  \"Transfer-Encoding\": true,\n  \"Upgrade\": true,\n  \"User-Agent\": true,\n  \"Via\": true\n};\n\n/*\n  Adds an \"event\" onto the fake xhr object\n  that just calls the same-named method. This is\n  in case a library adds callbacks for these events.\n*/\nfunction _addEventListener(eventName, xhr){\n  xhr.addEventListener(eventName, function (event) {\n    var listener = xhr[\"on\" + eventName];\n\n    if (listener && typeof listener == \"function\") {\n      listener.call(event.target, event);\n    }\n  });\n}\n\nfunction EventedObject() {\n  this._eventListeners = {};\n  var events = [\"loadstart\", \"progress\", \"load\", \"abort\", \"loadend\"];\n  for (var i = events.length - 1; i >= 0; i--) {\n    _addEventListener(events[i], this);\n  }\n};\n\nEventedObject.prototype = {\n  /*\n    Duplicates the behavior of native XMLHttpRequest's addEventListener function\n  */\n  addEventListener: function addEventListener(event, listener) {\n    this._eventListeners[event] = this._eventListeners[event] || [];\n    this._eventListeners[event].push(listener);\n  },\n\n  /*\n    Duplicates the behavior of native XMLHttpRequest's removeEventListener function\n  */\n  removeEventListener: function removeEventListener(event, listener) {\n    var listeners = this._eventListeners[event] || [];\n\n    for (var i = 0, l = listeners.length; i < l; ++i) {\n      if (listeners[i] == listener) {\n        return listeners.splice(i, 1);\n      }\n    }\n  },\n\n  /*\n    Duplicates the behavior of native XMLHttpRequest's dispatchEvent function\n  */\n  dispatchEvent: function dispatchEvent(event) {\n    var type = event.type;\n    var listeners = this._eventListeners[type] || [];\n\n    for (var i = 0; i < listeners.length; i++) {\n      if (typeof listeners[i] == \"function\") {\n        listeners[i].call(this, event);\n      } else {\n        listeners[i].handleEvent(event);\n      }\n    }\n\n    return !!event.defaultPrevented;\n  },\n\n  /*\n    Triggers an `onprogress` event with the given parameters.\n  */\n  _progress: function _progress(lengthComputable, loaded, total) {\n    var event = new _Event('progress');\n    event.target = this;\n    event.lengthComputable = lengthComputable;\n    event.loaded = loaded;\n    event.total = total;\n    this.dispatchEvent(event);\n  }\n}\n\n/*\n  Constructor for a fake window.XMLHttpRequest\n*/\nfunction FakeXMLHttpRequest() {\n  EventedObject.call(this);\n  this.readyState = FakeXMLHttpRequest.UNSENT;\n  this.requestHeaders = {};\n  this.requestBody = null;\n  this.status = 0;\n  this.statusText = \"\";\n  this.upload = new EventedObject();\n  this.onabort= null;\n  this.onerror= null;\n  this.onload= null;\n  this.onloadend= null;\n  this.onloadstart= null;\n  this.onprogress= null;\n  this.onreadystatechange= null;\n  this.ontimeout= null;\n}\n\nFakeXMLHttpRequest.prototype = new EventedObject();\n\n// These status codes are available on the native XMLHttpRequest\n// object, so we match that here in case a library is relying on them.\nFakeXMLHttpRequest.UNSENT = 0;\nFakeXMLHttpRequest.OPENED = 1;\nFakeXMLHttpRequest.HEADERS_RECEIVED = 2;\nFakeXMLHttpRequest.LOADING = 3;\nFakeXMLHttpRequest.DONE = 4;\n\nvar FakeXMLHttpRequestProto = {\n  UNSENT: 0,\n  OPENED: 1,\n  HEADERS_RECEIVED: 2,\n  LOADING: 3,\n  DONE: 4,\n  async: true,\n  withCredentials: false,\n\n  /*\n    Duplicates the behavior of native XMLHttpRequest's open function\n  */\n  open: function open(method, url, async, username, password) {\n    this.method = method;\n    this.url = url;\n    this.async = typeof async == \"boolean\" ? async : true;\n    this.username = username;\n    this.password = password;\n    this.responseText = null;\n    this.response = this.responseText;\n    this.responseXML = null;\n    this.responseURL = url;\n    this.requestHeaders = {};\n    this.sendFlag = false;\n    this._readyStateChange(FakeXMLHttpRequest.OPENED);\n  },\n\n  /*\n    Duplicates the behavior of native XMLHttpRequest's setRequestHeader function\n  */\n  setRequestHeader: function setRequestHeader(header, value) {\n    verifyState(this);\n\n    if (unsafeHeaders[header] || /^(Sec-|Proxy-)/.test(header)) {\n      throw new Error(\"Refused to set unsafe header \\\"\" + header + \"\\\"\");\n    }\n\n    if (this.requestHeaders[header]) {\n      this.requestHeaders[header] += \",\" + value;\n    } else {\n      this.requestHeaders[header] = value;\n    }\n  },\n\n  /*\n    Duplicates the behavior of native XMLHttpRequest's send function\n  */\n  send: function send(data) {\n    verifyState(this);\n\n    if (!/^(get|head)$/i.test(this.method)) {\n      var hasContentTypeHeader = false\n\n      Object.keys(this.requestHeaders).forEach(function (key) {\n        if (key.toLowerCase() === 'content-type') {\n          hasContentTypeHeader = true;\n        }\n      });\n\n      if (!hasContentTypeHeader && !(data || '').toString().match('FormData')) {\n        this.requestHeaders[\"Content-Type\"] = \"text/plain;charset=UTF-8\";\n      }\n\n      this.requestBody = data;\n    }\n\n    this.errorFlag = false;\n    this.sendFlag = this.async;\n    this._readyStateChange(FakeXMLHttpRequest.OPENED);\n\n    if (typeof this.onSend == \"function\") {\n      this.onSend(this);\n    }\n\n    this.dispatchEvent(new _Event(\"loadstart\", false, false, this));\n  },\n\n  /*\n    Duplicates the behavior of native XMLHttpRequest's abort function\n  */\n  abort: function abort() {\n    this.aborted = true;\n    this.responseText = null;\n    this.response = this.responseText;\n    this.errorFlag = true;\n    this.requestHeaders = {};\n\n    this.dispatchEvent(new _Event(\"abort\", false, false, this));\n\n    if (this.readyState > FakeXMLHttpRequest.UNSENT && this.sendFlag) {\n      this._readyStateChange(FakeXMLHttpRequest.UNSENT);\n      this.sendFlag = false;\n    }\n\n    if (typeof this.onerror === \"function\") {\n      this.onerror();\n    }\n  },\n\n  /*\n    Duplicates the behavior of native XMLHttpRequest's getResponseHeader function\n  */\n  getResponseHeader: function getResponseHeader(header) {\n    if (this.readyState < FakeXMLHttpRequest.HEADERS_RECEIVED) {\n      return null;\n    }\n\n    if (/^Set-Cookie2?$/i.test(header)) {\n      return null;\n    }\n\n    header = header.toLowerCase();\n\n    for (var h in this.responseHeaders) {\n      if (h.toLowerCase() == header) {\n        return this.responseHeaders[h];\n      }\n    }\n\n    return null;\n  },\n\n  /*\n    Duplicates the behavior of native XMLHttpRequest's getAllResponseHeaders function\n  */\n  getAllResponseHeaders: function getAllResponseHeaders() {\n    if (this.readyState < FakeXMLHttpRequest.HEADERS_RECEIVED) {\n      return \"\";\n    }\n\n    var headers = \"\";\n\n    for (var header in this.responseHeaders) {\n      if (this.responseHeaders.hasOwnProperty(header) && !/^Set-Cookie2?$/i.test(header)) {\n        headers += header + \": \" + this.responseHeaders[header] + \"\\r\\n\";\n      }\n    }\n\n    return headers;\n  },\n\n  /*\n   Duplicates the behavior of native XMLHttpRequest's overrideMimeType function\n   */\n  overrideMimeType: function overrideMimeType(mimeType) {\n    if (typeof mimeType === \"string\") {\n      this.forceMimeType = mimeType.toLowerCase();\n    }\n  },\n\n\n  /*\n    Places a FakeXMLHttpRequest object into the passed\n    state.\n  */\n  _readyStateChange: function _readyStateChange(state) {\n    this.readyState = state;\n\n    if (typeof this.onreadystatechange == \"function\") {\n      this.onreadystatechange(new _Event(\"readystatechange\"));\n    }\n\n    this.dispatchEvent(new _Event(\"readystatechange\"));\n\n    if (this.readyState == FakeXMLHttpRequest.DONE) {\n      this.dispatchEvent(new _Event(\"load\", false, false, this));\n    }\n    if (this.readyState == FakeXMLHttpRequest.UNSENT || this.readyState == FakeXMLHttpRequest.DONE) {\n      this.dispatchEvent(new _Event(\"loadend\", false, false, this));\n    }\n  },\n\n\n  /*\n    Sets the FakeXMLHttpRequest object's response headers and\n    places the object into readyState 2\n  */\n  _setResponseHeaders: function _setResponseHeaders(headers) {\n    this.responseHeaders = {};\n\n    for (var header in headers) {\n      if (headers.hasOwnProperty(header)) {\n          this.responseHeaders[header] = headers[header];\n      }\n    }\n\n    if (this.forceMimeType) {\n      this.responseHeaders['Content-Type'] = this.forceMimeType;\n    }\n\n    if (this.async) {\n      this._readyStateChange(FakeXMLHttpRequest.HEADERS_RECEIVED);\n    } else {\n      this.readyState = FakeXMLHttpRequest.HEADERS_RECEIVED;\n    }\n  },\n\n  /*\n    Sets the FakeXMLHttpRequest object's response body and\n    if body text is XML, sets responseXML to parsed document\n    object\n  */\n  _setResponseBody: function _setResponseBody(body) {\n    verifyRequestSent(this);\n    verifyHeadersReceived(this);\n    verifyResponseBodyType(body);\n\n    var chunkSize = this.chunkSize || 10;\n    var index = 0;\n    this.responseText = \"\";\n    this.response = this.responseText;\n\n    do {\n      if (this.async) {\n        this._readyStateChange(FakeXMLHttpRequest.LOADING);\n      }\n\n      this.responseText += body.substring(index, index + chunkSize);\n      this.response = this.responseText;\n      index += chunkSize;\n    } while (index < body.length);\n\n    var type = this.getResponseHeader(\"Content-Type\");\n\n    if (this.responseText && (!type || /(text\\/xml)|(application\\/xml)|(\\+xml)/.test(type))) {\n      try {\n        this.responseXML = parseXML(this.responseText);\n      } catch (e) {\n        // Unable to parse XML - no biggie\n      }\n    }\n\n    if (this.async) {\n      this._readyStateChange(FakeXMLHttpRequest.DONE);\n    } else {\n      this.readyState = FakeXMLHttpRequest.DONE;\n    }\n  },\n\n  /*\n    Forces a response on to the FakeXMLHttpRequest object.\n\n    This is the public API for faking responses. This function\n    takes a number status, headers object, and string body:\n\n    ```\n    xhr.respond(404, {Content-Type: 'text/plain'}, \"Sorry. This object was not found.\")\n\n    ```\n  */\n  respond: function respond(status, headers, body) {\n    this._setResponseHeaders(headers || {});\n    this.status = typeof status == \"number\" ? status : 200;\n    this.statusText = httpStatusCodes[this.status];\n    this._setResponseBody(body || \"\");\n  }\n};\n\nfor (var property in FakeXMLHttpRequestProto) {\n  FakeXMLHttpRequest.prototype[property] = FakeXMLHttpRequestProto[property];\n}\n\nfunction verifyState(xhr) {\n  if (xhr.readyState !== FakeXMLHttpRequest.OPENED) {\n    throw new Error(\"INVALID_STATE_ERR\");\n  }\n\n  if (xhr.sendFlag) {\n    throw new Error(\"INVALID_STATE_ERR\");\n  }\n}\n\n\nfunction verifyRequestSent(xhr) {\n    if (xhr.readyState == FakeXMLHttpRequest.DONE) {\n        throw new Error(\"Request done\");\n    }\n}\n\nfunction verifyHeadersReceived(xhr) {\n    if (xhr.async && xhr.readyState != FakeXMLHttpRequest.HEADERS_RECEIVED) {\n        throw new Error(\"No headers received\");\n    }\n}\n\nfunction verifyResponseBodyType(body) {\n    if (typeof body != \"string\") {\n        var error = new Error(\"Attempted to respond to fake XMLHttpRequest with \" +\n                             body + \", which is not a string.\");\n        error.name = \"InvalidBodyException\";\n        throw error;\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FakeXMLHttpRequest);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZmFrZS14bWwtaHR0cC1yZXF1ZXN0L3NyYy9mYWtlLXhtbC1odHRwLXJlcXVlc3QuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSwwREFBMEQ7QUFDMUQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsMkJBQTJCOztBQUVqRDtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWUsa0JBQWtCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZXN0YXBwLy4vbm9kZV9tb2R1bGVzL2Zha2UteG1sLWh0dHAtcmVxdWVzdC9zcmMvZmFrZS14bWwtaHR0cC1yZXF1ZXN0LmpzP2Q0NDAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBNaW5pbWFsIEV2ZW50IGludGVyZmFjZSBpbXBsZW1lbnRhdGlvblxuICpcbiAqIE9yaWdpbmFsIGltcGxlbWVudGF0aW9uIGJ5IFN2ZW4gRnVjaHM6IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tLzk5NTAyOFxuICogTW9kaWZpY2F0aW9ucyBhbmQgdGVzdHMgYnkgQ2hyaXN0aWFuIEpvaGFuc2VuLlxuICpcbiAqIEBhdXRob3IgU3ZlbiBGdWNocyAoc3ZlbmZ1Y2hzQGFydHdlYi1kZXNpZ24uZGUpXG4gKiBAYXV0aG9yIENocmlzdGlhbiBKb2hhbnNlbiAoY2hyaXN0aWFuQGNqb2hhbnNlbi5ubylcbiAqIEBsaWNlbnNlIEJTRFxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMSBTdmVuIEZ1Y2hzLCBDaHJpc3RpYW4gSm9oYW5zZW5cbiAqL1xuXG52YXIgX0V2ZW50ID0gZnVuY3Rpb24gRXZlbnQodHlwZSwgYnViYmxlcywgY2FuY2VsYWJsZSwgdGFyZ2V0KSB7XG4gIHRoaXMudHlwZSA9IHR5cGU7XG4gIHRoaXMuYnViYmxlcyA9IGJ1YmJsZXM7XG4gIHRoaXMuY2FuY2VsYWJsZSA9IGNhbmNlbGFibGU7XG4gIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xufTtcblxuX0V2ZW50LnByb3RvdHlwZSA9IHtcbiAgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbiAoKSB7fSxcbiAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xuICB9XG59O1xuXG4vKlxuICBVc2VkIHRvIHNldCB0aGUgc3RhdHVzVGV4dCBwcm9wZXJ0eSBvZiBhbiB4aHIgb2JqZWN0XG4qL1xudmFyIGh0dHBTdGF0dXNDb2RlcyA9IHtcbiAgMTAwOiBcIkNvbnRpbnVlXCIsXG4gIDEwMTogXCJTd2l0Y2hpbmcgUHJvdG9jb2xzXCIsXG4gIDIwMDogXCJPS1wiLFxuICAyMDE6IFwiQ3JlYXRlZFwiLFxuICAyMDI6IFwiQWNjZXB0ZWRcIixcbiAgMjAzOiBcIk5vbi1BdXRob3JpdGF0aXZlIEluZm9ybWF0aW9uXCIsXG4gIDIwNDogXCJObyBDb250ZW50XCIsXG4gIDIwNTogXCJSZXNldCBDb250ZW50XCIsXG4gIDIwNjogXCJQYXJ0aWFsIENvbnRlbnRcIixcbiAgMzAwOiBcIk11bHRpcGxlIENob2ljZVwiLFxuICAzMDE6IFwiTW92ZWQgUGVybWFuZW50bHlcIixcbiAgMzAyOiBcIkZvdW5kXCIsXG4gIDMwMzogXCJTZWUgT3RoZXJcIixcbiAgMzA0OiBcIk5vdCBNb2RpZmllZFwiLFxuICAzMDU6IFwiVXNlIFByb3h5XCIsXG4gIDMwNzogXCJUZW1wb3JhcnkgUmVkaXJlY3RcIixcbiAgNDAwOiBcIkJhZCBSZXF1ZXN0XCIsXG4gIDQwMTogXCJVbmF1dGhvcml6ZWRcIixcbiAgNDAyOiBcIlBheW1lbnQgUmVxdWlyZWRcIixcbiAgNDAzOiBcIkZvcmJpZGRlblwiLFxuICA0MDQ6IFwiTm90IEZvdW5kXCIsXG4gIDQwNTogXCJNZXRob2QgTm90IEFsbG93ZWRcIixcbiAgNDA2OiBcIk5vdCBBY2NlcHRhYmxlXCIsXG4gIDQwNzogXCJQcm94eSBBdXRoZW50aWNhdGlvbiBSZXF1aXJlZFwiLFxuICA0MDg6IFwiUmVxdWVzdCBUaW1lb3V0XCIsXG4gIDQwOTogXCJDb25mbGljdFwiLFxuICA0MTA6IFwiR29uZVwiLFxuICA0MTE6IFwiTGVuZ3RoIFJlcXVpcmVkXCIsXG4gIDQxMjogXCJQcmVjb25kaXRpb24gRmFpbGVkXCIsXG4gIDQxMzogXCJSZXF1ZXN0IEVudGl0eSBUb28gTGFyZ2VcIixcbiAgNDE0OiBcIlJlcXVlc3QtVVJJIFRvbyBMb25nXCIsXG4gIDQxNTogXCJVbnN1cHBvcnRlZCBNZWRpYSBUeXBlXCIsXG4gIDQxNjogXCJSZXF1ZXN0ZWQgUmFuZ2UgTm90IFNhdGlzZmlhYmxlXCIsXG4gIDQxNzogXCJFeHBlY3RhdGlvbiBGYWlsZWRcIixcbiAgNDIyOiBcIlVucHJvY2Vzc2FibGUgRW50aXR5XCIsXG4gIDUwMDogXCJJbnRlcm5hbCBTZXJ2ZXIgRXJyb3JcIixcbiAgNTAxOiBcIk5vdCBJbXBsZW1lbnRlZFwiLFxuICA1MDI6IFwiQmFkIEdhdGV3YXlcIixcbiAgNTAzOiBcIlNlcnZpY2UgVW5hdmFpbGFibGVcIixcbiAgNTA0OiBcIkdhdGV3YXkgVGltZW91dFwiLFxuICA1MDU6IFwiSFRUUCBWZXJzaW9uIE5vdCBTdXBwb3J0ZWRcIlxufTtcblxuXG4vKlxuICBDcm9zcy1icm93c2VyIFhNTCBwYXJzaW5nLiBVc2VkIHRvIHR1cm5cbiAgWE1MIHJlc3BvbnNlcyBpbnRvIERvY3VtZW50IG9iamVjdHNcbiAgQm9ycm93ZWQgZnJvbSBKU3BlY1xuKi9cbmZ1bmN0aW9uIHBhcnNlWE1MKHRleHQpIHtcbiAgdmFyIHhtbERvYztcblxuICBpZiAodHlwZW9mIERPTVBhcnNlciAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdmFyIHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcbiAgICB4bWxEb2MgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHRleHQsIFwidGV4dC94bWxcIik7XG4gIH0gZWxzZSB7XG4gICAgeG1sRG9jID0gbmV3IEFjdGl2ZVhPYmplY3QoXCJNaWNyb3NvZnQuWE1MRE9NXCIpO1xuICAgIHhtbERvYy5hc3luYyA9IFwiZmFsc2VcIjtcbiAgICB4bWxEb2MubG9hZFhNTCh0ZXh0KTtcbiAgfVxuXG4gIHJldHVybiB4bWxEb2M7XG59XG5cbi8qXG4gIFdpdGhvdXQgbW9ja2luZywgdGhlIG5hdGl2ZSBYTUxIdHRwUmVxdWVzdCBvYmplY3Qgd2lsbCB0aHJvd1xuICBhbiBlcnJvciB3aGVuIGF0dGVtcHRpbmcgdG8gc2V0IHRoZXNlIGhlYWRlcnMuIFdlIG1hdGNoIHRoaXMgYmVoYXZpb3IuXG4qL1xudmFyIHVuc2FmZUhlYWRlcnMgPSB7XG4gIFwiQWNjZXB0LUNoYXJzZXRcIjogdHJ1ZSxcbiAgXCJBY2NlcHQtRW5jb2RpbmdcIjogdHJ1ZSxcbiAgXCJDb25uZWN0aW9uXCI6IHRydWUsXG4gIFwiQ29udGVudC1MZW5ndGhcIjogdHJ1ZSxcbiAgXCJDb29raWVcIjogdHJ1ZSxcbiAgXCJDb29raWUyXCI6IHRydWUsXG4gIFwiQ29udGVudC1UcmFuc2Zlci1FbmNvZGluZ1wiOiB0cnVlLFxuICBcIkRhdGVcIjogdHJ1ZSxcbiAgXCJFeHBlY3RcIjogdHJ1ZSxcbiAgXCJIb3N0XCI6IHRydWUsXG4gIFwiS2VlcC1BbGl2ZVwiOiB0cnVlLFxuICBcIlJlZmVyZXJcIjogdHJ1ZSxcbiAgXCJURVwiOiB0cnVlLFxuICBcIlRyYWlsZXJcIjogdHJ1ZSxcbiAgXCJUcmFuc2Zlci1FbmNvZGluZ1wiOiB0cnVlLFxuICBcIlVwZ3JhZGVcIjogdHJ1ZSxcbiAgXCJVc2VyLUFnZW50XCI6IHRydWUsXG4gIFwiVmlhXCI6IHRydWVcbn07XG5cbi8qXG4gIEFkZHMgYW4gXCJldmVudFwiIG9udG8gdGhlIGZha2UgeGhyIG9iamVjdFxuICB0aGF0IGp1c3QgY2FsbHMgdGhlIHNhbWUtbmFtZWQgbWV0aG9kLiBUaGlzIGlzXG4gIGluIGNhc2UgYSBsaWJyYXJ5IGFkZHMgY2FsbGJhY2tzIGZvciB0aGVzZSBldmVudHMuXG4qL1xuZnVuY3Rpb24gX2FkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCB4aHIpe1xuICB4aHIuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBsaXN0ZW5lciA9IHhocltcIm9uXCIgKyBldmVudE5hbWVdO1xuXG4gICAgaWYgKGxpc3RlbmVyICYmIHR5cGVvZiBsaXN0ZW5lciA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGxpc3RlbmVyLmNhbGwoZXZlbnQudGFyZ2V0LCBldmVudCk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gRXZlbnRlZE9iamVjdCgpIHtcbiAgdGhpcy5fZXZlbnRMaXN0ZW5lcnMgPSB7fTtcbiAgdmFyIGV2ZW50cyA9IFtcImxvYWRzdGFydFwiLCBcInByb2dyZXNzXCIsIFwibG9hZFwiLCBcImFib3J0XCIsIFwibG9hZGVuZFwiXTtcbiAgZm9yICh2YXIgaSA9IGV2ZW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIF9hZGRFdmVudExpc3RlbmVyKGV2ZW50c1tpXSwgdGhpcyk7XG4gIH1cbn07XG5cbkV2ZW50ZWRPYmplY3QucHJvdG90eXBlID0ge1xuICAvKlxuICAgIER1cGxpY2F0ZXMgdGhlIGJlaGF2aW9yIG9mIG5hdGl2ZSBYTUxIdHRwUmVxdWVzdCdzIGFkZEV2ZW50TGlzdGVuZXIgZnVuY3Rpb25cbiAgKi9cbiAgYWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpIHtcbiAgICB0aGlzLl9ldmVudExpc3RlbmVyc1tldmVudF0gPSB0aGlzLl9ldmVudExpc3RlbmVyc1tldmVudF0gfHwgW107XG4gICAgdGhpcy5fZXZlbnRMaXN0ZW5lcnNbZXZlbnRdLnB1c2gobGlzdGVuZXIpO1xuICB9LFxuXG4gIC8qXG4gICAgRHVwbGljYXRlcyB0aGUgYmVoYXZpb3Igb2YgbmF0aXZlIFhNTEh0dHBSZXF1ZXN0J3MgcmVtb3ZlRXZlbnRMaXN0ZW5lciBmdW5jdGlvblxuICAqL1xuICByZW1vdmVFdmVudExpc3RlbmVyOiBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudExpc3RlbmVyc1tldmVudF0gfHwgW107XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgIGlmIChsaXN0ZW5lcnNbaV0gPT0gbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qXG4gICAgRHVwbGljYXRlcyB0aGUgYmVoYXZpb3Igb2YgbmF0aXZlIFhNTEh0dHBSZXF1ZXN0J3MgZGlzcGF0Y2hFdmVudCBmdW5jdGlvblxuICAqL1xuICBkaXNwYXRjaEV2ZW50OiBmdW5jdGlvbiBkaXNwYXRjaEV2ZW50KGV2ZW50KSB7XG4gICAgdmFyIHR5cGUgPSBldmVudC50eXBlO1xuICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudExpc3RlbmVyc1t0eXBlXSB8fCBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVyc1tpXSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgbGlzdGVuZXJzW2ldLmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGlzdGVuZXJzW2ldLmhhbmRsZUV2ZW50KGV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gISFldmVudC5kZWZhdWx0UHJldmVudGVkO1xuICB9LFxuXG4gIC8qXG4gICAgVHJpZ2dlcnMgYW4gYG9ucHJvZ3Jlc3NgIGV2ZW50IHdpdGggdGhlIGdpdmVuIHBhcmFtZXRlcnMuXG4gICovXG4gIF9wcm9ncmVzczogZnVuY3Rpb24gX3Byb2dyZXNzKGxlbmd0aENvbXB1dGFibGUsIGxvYWRlZCwgdG90YWwpIHtcbiAgICB2YXIgZXZlbnQgPSBuZXcgX0V2ZW50KCdwcm9ncmVzcycpO1xuICAgIGV2ZW50LnRhcmdldCA9IHRoaXM7XG4gICAgZXZlbnQubGVuZ3RoQ29tcHV0YWJsZSA9IGxlbmd0aENvbXB1dGFibGU7XG4gICAgZXZlbnQubG9hZGVkID0gbG9hZGVkO1xuICAgIGV2ZW50LnRvdGFsID0gdG90YWw7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgfVxufVxuXG4vKlxuICBDb25zdHJ1Y3RvciBmb3IgYSBmYWtlIHdpbmRvdy5YTUxIdHRwUmVxdWVzdFxuKi9cbmZ1bmN0aW9uIEZha2VYTUxIdHRwUmVxdWVzdCgpIHtcbiAgRXZlbnRlZE9iamVjdC5jYWxsKHRoaXMpO1xuICB0aGlzLnJlYWR5U3RhdGUgPSBGYWtlWE1MSHR0cFJlcXVlc3QuVU5TRU5UO1xuICB0aGlzLnJlcXVlc3RIZWFkZXJzID0ge307XG4gIHRoaXMucmVxdWVzdEJvZHkgPSBudWxsO1xuICB0aGlzLnN0YXR1cyA9IDA7XG4gIHRoaXMuc3RhdHVzVGV4dCA9IFwiXCI7XG4gIHRoaXMudXBsb2FkID0gbmV3IEV2ZW50ZWRPYmplY3QoKTtcbiAgdGhpcy5vbmFib3J0PSBudWxsO1xuICB0aGlzLm9uZXJyb3I9IG51bGw7XG4gIHRoaXMub25sb2FkPSBudWxsO1xuICB0aGlzLm9ubG9hZGVuZD0gbnVsbDtcbiAgdGhpcy5vbmxvYWRzdGFydD0gbnVsbDtcbiAgdGhpcy5vbnByb2dyZXNzPSBudWxsO1xuICB0aGlzLm9ucmVhZHlzdGF0ZWNoYW5nZT0gbnVsbDtcbiAgdGhpcy5vbnRpbWVvdXQ9IG51bGw7XG59XG5cbkZha2VYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUgPSBuZXcgRXZlbnRlZE9iamVjdCgpO1xuXG4vLyBUaGVzZSBzdGF0dXMgY29kZXMgYXJlIGF2YWlsYWJsZSBvbiB0aGUgbmF0aXZlIFhNTEh0dHBSZXF1ZXN0XG4vLyBvYmplY3QsIHNvIHdlIG1hdGNoIHRoYXQgaGVyZSBpbiBjYXNlIGEgbGlicmFyeSBpcyByZWx5aW5nIG9uIHRoZW0uXG5GYWtlWE1MSHR0cFJlcXVlc3QuVU5TRU5UID0gMDtcbkZha2VYTUxIdHRwUmVxdWVzdC5PUEVORUQgPSAxO1xuRmFrZVhNTEh0dHBSZXF1ZXN0LkhFQURFUlNfUkVDRUlWRUQgPSAyO1xuRmFrZVhNTEh0dHBSZXF1ZXN0LkxPQURJTkcgPSAzO1xuRmFrZVhNTEh0dHBSZXF1ZXN0LkRPTkUgPSA0O1xuXG52YXIgRmFrZVhNTEh0dHBSZXF1ZXN0UHJvdG8gPSB7XG4gIFVOU0VOVDogMCxcbiAgT1BFTkVEOiAxLFxuICBIRUFERVJTX1JFQ0VJVkVEOiAyLFxuICBMT0FESU5HOiAzLFxuICBET05FOiA0LFxuICBhc3luYzogdHJ1ZSxcbiAgd2l0aENyZWRlbnRpYWxzOiBmYWxzZSxcblxuICAvKlxuICAgIER1cGxpY2F0ZXMgdGhlIGJlaGF2aW9yIG9mIG5hdGl2ZSBYTUxIdHRwUmVxdWVzdCdzIG9wZW4gZnVuY3Rpb25cbiAgKi9cbiAgb3BlbjogZnVuY3Rpb24gb3BlbihtZXRob2QsIHVybCwgYXN5bmMsIHVzZXJuYW1lLCBwYXNzd29yZCkge1xuICAgIHRoaXMubWV0aG9kID0gbWV0aG9kO1xuICAgIHRoaXMudXJsID0gdXJsO1xuICAgIHRoaXMuYXN5bmMgPSB0eXBlb2YgYXN5bmMgPT0gXCJib29sZWFuXCIgPyBhc3luYyA6IHRydWU7XG4gICAgdGhpcy51c2VybmFtZSA9IHVzZXJuYW1lO1xuICAgIHRoaXMucGFzc3dvcmQgPSBwYXNzd29yZDtcbiAgICB0aGlzLnJlc3BvbnNlVGV4dCA9IG51bGw7XG4gICAgdGhpcy5yZXNwb25zZSA9IHRoaXMucmVzcG9uc2VUZXh0O1xuICAgIHRoaXMucmVzcG9uc2VYTUwgPSBudWxsO1xuICAgIHRoaXMucmVzcG9uc2VVUkwgPSB1cmw7XG4gICAgdGhpcy5yZXF1ZXN0SGVhZGVycyA9IHt9O1xuICAgIHRoaXMuc2VuZEZsYWcgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkeVN0YXRlQ2hhbmdlKEZha2VYTUxIdHRwUmVxdWVzdC5PUEVORUQpO1xuICB9LFxuXG4gIC8qXG4gICAgRHVwbGljYXRlcyB0aGUgYmVoYXZpb3Igb2YgbmF0aXZlIFhNTEh0dHBSZXF1ZXN0J3Mgc2V0UmVxdWVzdEhlYWRlciBmdW5jdGlvblxuICAqL1xuICBzZXRSZXF1ZXN0SGVhZGVyOiBmdW5jdGlvbiBzZXRSZXF1ZXN0SGVhZGVyKGhlYWRlciwgdmFsdWUpIHtcbiAgICB2ZXJpZnlTdGF0ZSh0aGlzKTtcblxuICAgIGlmICh1bnNhZmVIZWFkZXJzW2hlYWRlcl0gfHwgL14oU2VjLXxQcm94eS0pLy50ZXN0KGhlYWRlcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlZnVzZWQgdG8gc2V0IHVuc2FmZSBoZWFkZXIgXFxcIlwiICsgaGVhZGVyICsgXCJcXFwiXCIpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJlcXVlc3RIZWFkZXJzW2hlYWRlcl0pIHtcbiAgICAgIHRoaXMucmVxdWVzdEhlYWRlcnNbaGVhZGVyXSArPSBcIixcIiArIHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlcXVlc3RIZWFkZXJzW2hlYWRlcl0gPSB2YWx1ZTtcbiAgICB9XG4gIH0sXG5cbiAgLypcbiAgICBEdXBsaWNhdGVzIHRoZSBiZWhhdmlvciBvZiBuYXRpdmUgWE1MSHR0cFJlcXVlc3QncyBzZW5kIGZ1bmN0aW9uXG4gICovXG4gIHNlbmQ6IGZ1bmN0aW9uIHNlbmQoZGF0YSkge1xuICAgIHZlcmlmeVN0YXRlKHRoaXMpO1xuXG4gICAgaWYgKCEvXihnZXR8aGVhZCkkL2kudGVzdCh0aGlzLm1ldGhvZCkpIHtcbiAgICAgIHZhciBoYXNDb250ZW50VHlwZUhlYWRlciA9IGZhbHNlXG5cbiAgICAgIE9iamVjdC5rZXlzKHRoaXMucmVxdWVzdEhlYWRlcnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoa2V5LnRvTG93ZXJDYXNlKCkgPT09ICdjb250ZW50LXR5cGUnKSB7XG4gICAgICAgICAgaGFzQ29udGVudFR5cGVIZWFkZXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKCFoYXNDb250ZW50VHlwZUhlYWRlciAmJiAhKGRhdGEgfHwgJycpLnRvU3RyaW5nKCkubWF0Y2goJ0Zvcm1EYXRhJykpIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0SGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSA9IFwidGV4dC9wbGFpbjtjaGFyc2V0PVVURi04XCI7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVxdWVzdEJvZHkgPSBkYXRhO1xuICAgIH1cblxuICAgIHRoaXMuZXJyb3JGbGFnID0gZmFsc2U7XG4gICAgdGhpcy5zZW5kRmxhZyA9IHRoaXMuYXN5bmM7XG4gICAgdGhpcy5fcmVhZHlTdGF0ZUNoYW5nZShGYWtlWE1MSHR0cFJlcXVlc3QuT1BFTkVEKTtcblxuICAgIGlmICh0eXBlb2YgdGhpcy5vblNlbmQgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aGlzLm9uU2VuZCh0aGlzKTtcbiAgICB9XG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IF9FdmVudChcImxvYWRzdGFydFwiLCBmYWxzZSwgZmFsc2UsIHRoaXMpKTtcbiAgfSxcblxuICAvKlxuICAgIER1cGxpY2F0ZXMgdGhlIGJlaGF2aW9yIG9mIG5hdGl2ZSBYTUxIdHRwUmVxdWVzdCdzIGFib3J0IGZ1bmN0aW9uXG4gICovXG4gIGFib3J0OiBmdW5jdGlvbiBhYm9ydCgpIHtcbiAgICB0aGlzLmFib3J0ZWQgPSB0cnVlO1xuICAgIHRoaXMucmVzcG9uc2VUZXh0ID0gbnVsbDtcbiAgICB0aGlzLnJlc3BvbnNlID0gdGhpcy5yZXNwb25zZVRleHQ7XG4gICAgdGhpcy5lcnJvckZsYWcgPSB0cnVlO1xuICAgIHRoaXMucmVxdWVzdEhlYWRlcnMgPSB7fTtcblxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgX0V2ZW50KFwiYWJvcnRcIiwgZmFsc2UsIGZhbHNlLCB0aGlzKSk7XG5cbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID4gRmFrZVhNTEh0dHBSZXF1ZXN0LlVOU0VOVCAmJiB0aGlzLnNlbmRGbGFnKSB7XG4gICAgICB0aGlzLl9yZWFkeVN0YXRlQ2hhbmdlKEZha2VYTUxIdHRwUmVxdWVzdC5VTlNFTlQpO1xuICAgICAgdGhpcy5zZW5kRmxhZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGhpcy5vbmVycm9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRoaXMub25lcnJvcigpO1xuICAgIH1cbiAgfSxcblxuICAvKlxuICAgIER1cGxpY2F0ZXMgdGhlIGJlaGF2aW9yIG9mIG5hdGl2ZSBYTUxIdHRwUmVxdWVzdCdzIGdldFJlc3BvbnNlSGVhZGVyIGZ1bmN0aW9uXG4gICovXG4gIGdldFJlc3BvbnNlSGVhZGVyOiBmdW5jdGlvbiBnZXRSZXNwb25zZUhlYWRlcihoZWFkZXIpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlIDwgRmFrZVhNTEh0dHBSZXF1ZXN0LkhFQURFUlNfUkVDRUlWRUQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICgvXlNldC1Db29raWUyPyQvaS50ZXN0KGhlYWRlcikpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGhlYWRlciA9IGhlYWRlci50b0xvd2VyQ2FzZSgpO1xuXG4gICAgZm9yICh2YXIgaCBpbiB0aGlzLnJlc3BvbnNlSGVhZGVycykge1xuICAgICAgaWYgKGgudG9Mb3dlckNhc2UoKSA9PSBoZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzcG9uc2VIZWFkZXJzW2hdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9LFxuXG4gIC8qXG4gICAgRHVwbGljYXRlcyB0aGUgYmVoYXZpb3Igb2YgbmF0aXZlIFhNTEh0dHBSZXF1ZXN0J3MgZ2V0QWxsUmVzcG9uc2VIZWFkZXJzIGZ1bmN0aW9uXG4gICovXG4gIGdldEFsbFJlc3BvbnNlSGVhZGVyczogZnVuY3Rpb24gZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPCBGYWtlWE1MSHR0cFJlcXVlc3QuSEVBREVSU19SRUNFSVZFRCkge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuXG4gICAgdmFyIGhlYWRlcnMgPSBcIlwiO1xuXG4gICAgZm9yICh2YXIgaGVhZGVyIGluIHRoaXMucmVzcG9uc2VIZWFkZXJzKSB7XG4gICAgICBpZiAodGhpcy5yZXNwb25zZUhlYWRlcnMuaGFzT3duUHJvcGVydHkoaGVhZGVyKSAmJiAhL15TZXQtQ29va2llMj8kL2kudGVzdChoZWFkZXIpKSB7XG4gICAgICAgIGhlYWRlcnMgKz0gaGVhZGVyICsgXCI6IFwiICsgdGhpcy5yZXNwb25zZUhlYWRlcnNbaGVhZGVyXSArIFwiXFxyXFxuXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGhlYWRlcnM7XG4gIH0sXG5cbiAgLypcbiAgIER1cGxpY2F0ZXMgdGhlIGJlaGF2aW9yIG9mIG5hdGl2ZSBYTUxIdHRwUmVxdWVzdCdzIG92ZXJyaWRlTWltZVR5cGUgZnVuY3Rpb25cbiAgICovXG4gIG92ZXJyaWRlTWltZVR5cGU6IGZ1bmN0aW9uIG92ZXJyaWRlTWltZVR5cGUobWltZVR5cGUpIHtcbiAgICBpZiAodHlwZW9mIG1pbWVUeXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aGlzLmZvcmNlTWltZVR5cGUgPSBtaW1lVHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgfSxcblxuXG4gIC8qXG4gICAgUGxhY2VzIGEgRmFrZVhNTEh0dHBSZXF1ZXN0IG9iamVjdCBpbnRvIHRoZSBwYXNzZWRcbiAgICBzdGF0ZS5cbiAgKi9cbiAgX3JlYWR5U3RhdGVDaGFuZ2U6IGZ1bmN0aW9uIF9yZWFkeVN0YXRlQ2hhbmdlKHN0YXRlKSB7XG4gICAgdGhpcy5yZWFkeVN0YXRlID0gc3RhdGU7XG5cbiAgICBpZiAodHlwZW9mIHRoaXMub25yZWFkeXN0YXRlY2hhbmdlID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhpcy5vbnJlYWR5c3RhdGVjaGFuZ2UobmV3IF9FdmVudChcInJlYWR5c3RhdGVjaGFuZ2VcIikpO1xuICAgIH1cblxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgX0V2ZW50KFwicmVhZHlzdGF0ZWNoYW5nZVwiKSk7XG5cbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09IEZha2VYTUxIdHRwUmVxdWVzdC5ET05FKSB7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IF9FdmVudChcImxvYWRcIiwgZmFsc2UsIGZhbHNlLCB0aGlzKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT0gRmFrZVhNTEh0dHBSZXF1ZXN0LlVOU0VOVCB8fCB0aGlzLnJlYWR5U3RhdGUgPT0gRmFrZVhNTEh0dHBSZXF1ZXN0LkRPTkUpIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgX0V2ZW50KFwibG9hZGVuZFwiLCBmYWxzZSwgZmFsc2UsIHRoaXMpKTtcbiAgICB9XG4gIH0sXG5cblxuICAvKlxuICAgIFNldHMgdGhlIEZha2VYTUxIdHRwUmVxdWVzdCBvYmplY3QncyByZXNwb25zZSBoZWFkZXJzIGFuZFxuICAgIHBsYWNlcyB0aGUgb2JqZWN0IGludG8gcmVhZHlTdGF0ZSAyXG4gICovXG4gIF9zZXRSZXNwb25zZUhlYWRlcnM6IGZ1bmN0aW9uIF9zZXRSZXNwb25zZUhlYWRlcnMoaGVhZGVycykge1xuICAgIHRoaXMucmVzcG9uc2VIZWFkZXJzID0ge307XG5cbiAgICBmb3IgKHZhciBoZWFkZXIgaW4gaGVhZGVycykge1xuICAgICAgaWYgKGhlYWRlcnMuaGFzT3duUHJvcGVydHkoaGVhZGVyKSkge1xuICAgICAgICAgIHRoaXMucmVzcG9uc2VIZWFkZXJzW2hlYWRlcl0gPSBoZWFkZXJzW2hlYWRlcl07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZm9yY2VNaW1lVHlwZSkge1xuICAgICAgdGhpcy5yZXNwb25zZUhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gdGhpcy5mb3JjZU1pbWVUeXBlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmFzeW5jKSB7XG4gICAgICB0aGlzLl9yZWFkeVN0YXRlQ2hhbmdlKEZha2VYTUxIdHRwUmVxdWVzdC5IRUFERVJTX1JFQ0VJVkVEKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZWFkeVN0YXRlID0gRmFrZVhNTEh0dHBSZXF1ZXN0LkhFQURFUlNfUkVDRUlWRUQ7XG4gICAgfVxuICB9LFxuXG4gIC8qXG4gICAgU2V0cyB0aGUgRmFrZVhNTEh0dHBSZXF1ZXN0IG9iamVjdCdzIHJlc3BvbnNlIGJvZHkgYW5kXG4gICAgaWYgYm9keSB0ZXh0IGlzIFhNTCwgc2V0cyByZXNwb25zZVhNTCB0byBwYXJzZWQgZG9jdW1lbnRcbiAgICBvYmplY3RcbiAgKi9cbiAgX3NldFJlc3BvbnNlQm9keTogZnVuY3Rpb24gX3NldFJlc3BvbnNlQm9keShib2R5KSB7XG4gICAgdmVyaWZ5UmVxdWVzdFNlbnQodGhpcyk7XG4gICAgdmVyaWZ5SGVhZGVyc1JlY2VpdmVkKHRoaXMpO1xuICAgIHZlcmlmeVJlc3BvbnNlQm9keVR5cGUoYm9keSk7XG5cbiAgICB2YXIgY2h1bmtTaXplID0gdGhpcy5jaHVua1NpemUgfHwgMTA7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB0aGlzLnJlc3BvbnNlVGV4dCA9IFwiXCI7XG4gICAgdGhpcy5yZXNwb25zZSA9IHRoaXMucmVzcG9uc2VUZXh0O1xuXG4gICAgZG8ge1xuICAgICAgaWYgKHRoaXMuYXN5bmMpIHtcbiAgICAgICAgdGhpcy5fcmVhZHlTdGF0ZUNoYW5nZShGYWtlWE1MSHR0cFJlcXVlc3QuTE9BRElORyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVzcG9uc2VUZXh0ICs9IGJvZHkuc3Vic3RyaW5nKGluZGV4LCBpbmRleCArIGNodW5rU2l6ZSk7XG4gICAgICB0aGlzLnJlc3BvbnNlID0gdGhpcy5yZXNwb25zZVRleHQ7XG4gICAgICBpbmRleCArPSBjaHVua1NpemU7XG4gICAgfSB3aGlsZSAoaW5kZXggPCBib2R5Lmxlbmd0aCk7XG5cbiAgICB2YXIgdHlwZSA9IHRoaXMuZ2V0UmVzcG9uc2VIZWFkZXIoXCJDb250ZW50LVR5cGVcIik7XG5cbiAgICBpZiAodGhpcy5yZXNwb25zZVRleHQgJiYgKCF0eXBlIHx8IC8odGV4dFxcL3htbCl8KGFwcGxpY2F0aW9uXFwveG1sKXwoXFwreG1sKS8udGVzdCh0eXBlKSkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMucmVzcG9uc2VYTUwgPSBwYXJzZVhNTCh0aGlzLnJlc3BvbnNlVGV4dCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIFVuYWJsZSB0byBwYXJzZSBYTUwgLSBubyBiaWdnaWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5hc3luYykge1xuICAgICAgdGhpcy5fcmVhZHlTdGF0ZUNoYW5nZShGYWtlWE1MSHR0cFJlcXVlc3QuRE9ORSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IEZha2VYTUxIdHRwUmVxdWVzdC5ET05FO1xuICAgIH1cbiAgfSxcblxuICAvKlxuICAgIEZvcmNlcyBhIHJlc3BvbnNlIG9uIHRvIHRoZSBGYWtlWE1MSHR0cFJlcXVlc3Qgb2JqZWN0LlxuXG4gICAgVGhpcyBpcyB0aGUgcHVibGljIEFQSSBmb3IgZmFraW5nIHJlc3BvbnNlcy4gVGhpcyBmdW5jdGlvblxuICAgIHRha2VzIGEgbnVtYmVyIHN0YXR1cywgaGVhZGVycyBvYmplY3QsIGFuZCBzdHJpbmcgYm9keTpcblxuICAgIGBgYFxuICAgIHhoci5yZXNwb25kKDQwNCwge0NvbnRlbnQtVHlwZTogJ3RleHQvcGxhaW4nfSwgXCJTb3JyeS4gVGhpcyBvYmplY3Qgd2FzIG5vdCBmb3VuZC5cIilcblxuICAgIGBgYFxuICAqL1xuICByZXNwb25kOiBmdW5jdGlvbiByZXNwb25kKHN0YXR1cywgaGVhZGVycywgYm9keSkge1xuICAgIHRoaXMuX3NldFJlc3BvbnNlSGVhZGVycyhoZWFkZXJzIHx8IHt9KTtcbiAgICB0aGlzLnN0YXR1cyA9IHR5cGVvZiBzdGF0dXMgPT0gXCJudW1iZXJcIiA/IHN0YXR1cyA6IDIwMDtcbiAgICB0aGlzLnN0YXR1c1RleHQgPSBodHRwU3RhdHVzQ29kZXNbdGhpcy5zdGF0dXNdO1xuICAgIHRoaXMuX3NldFJlc3BvbnNlQm9keShib2R5IHx8IFwiXCIpO1xuICB9XG59O1xuXG5mb3IgKHZhciBwcm9wZXJ0eSBpbiBGYWtlWE1MSHR0cFJlcXVlc3RQcm90bykge1xuICBGYWtlWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlW3Byb3BlcnR5XSA9IEZha2VYTUxIdHRwUmVxdWVzdFByb3RvW3Byb3BlcnR5XTtcbn1cblxuZnVuY3Rpb24gdmVyaWZ5U3RhdGUoeGhyKSB7XG4gIGlmICh4aHIucmVhZHlTdGF0ZSAhPT0gRmFrZVhNTEh0dHBSZXF1ZXN0Lk9QRU5FRCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIklOVkFMSURfU1RBVEVfRVJSXCIpO1xuICB9XG5cbiAgaWYgKHhoci5zZW5kRmxhZykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIklOVkFMSURfU1RBVEVfRVJSXCIpO1xuICB9XG59XG5cblxuZnVuY3Rpb24gdmVyaWZ5UmVxdWVzdFNlbnQoeGhyKSB7XG4gICAgaWYgKHhoci5yZWFkeVN0YXRlID09IEZha2VYTUxIdHRwUmVxdWVzdC5ET05FKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlcXVlc3QgZG9uZVwiKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHZlcmlmeUhlYWRlcnNSZWNlaXZlZCh4aHIpIHtcbiAgICBpZiAoeGhyLmFzeW5jICYmIHhoci5yZWFkeVN0YXRlICE9IEZha2VYTUxIdHRwUmVxdWVzdC5IRUFERVJTX1JFQ0VJVkVEKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGhlYWRlcnMgcmVjZWl2ZWRcIik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB2ZXJpZnlSZXNwb25zZUJvZHlUeXBlKGJvZHkpIHtcbiAgICBpZiAodHlwZW9mIGJvZHkgIT0gXCJzdHJpbmdcIikge1xuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXCJBdHRlbXB0ZWQgdG8gcmVzcG9uZCB0byBmYWtlIFhNTEh0dHBSZXF1ZXN0IHdpdGggXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5ICsgXCIsIHdoaWNoIGlzIG5vdCBhIHN0cmluZy5cIik7XG4gICAgICAgIGVycm9yLm5hbWUgPSBcIkludmFsaWRCb2R5RXhjZXB0aW9uXCI7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn1cbmV4cG9ydCBkZWZhdWx0IEZha2VYTUxIdHRwUmVxdWVzdDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/fake-xml-http-request/src/fake-xml-http-request.js\n");

/***/ })

};
;