"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/route-recognizer";
exports.ids = ["vendor-chunks/route-recognizer"];
exports.modules = {

/***/ "(rsc)/./node_modules/route-recognizer/dist/route-recognizer.es.js":
/*!*******************************************************************!*\
  !*** ./node_modules/route-recognizer/dist/route-recognizer.es.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nvar createObject = Object.create;\nfunction createMap() {\n    var map = createObject(null);\n    map[\"__\"] = undefined;\n    delete map[\"__\"];\n    return map;\n}\n\nvar Target = function Target(path, matcher, delegate) {\n    this.path = path;\n    this.matcher = matcher;\n    this.delegate = delegate;\n};\nTarget.prototype.to = function to (target, callback) {\n    var delegate = this.delegate;\n    if (delegate && delegate.willAddRoute) {\n        target = delegate.willAddRoute(this.matcher.target, target);\n    }\n    this.matcher.add(this.path, target);\n    if (callback) {\n        if (callback.length === 0) {\n            throw new Error(\"You must have an argument in the function passed to `to`\");\n        }\n        this.matcher.addChild(this.path, target, callback, this.delegate);\n    }\n};\nvar Matcher = function Matcher(target) {\n    this.routes = createMap();\n    this.children = createMap();\n    this.target = target;\n};\nMatcher.prototype.add = function add (path, target) {\n    this.routes[path] = target;\n};\nMatcher.prototype.addChild = function addChild (path, target, callback, delegate) {\n    var matcher = new Matcher(target);\n    this.children[path] = matcher;\n    var match = generateMatch(path, matcher, delegate);\n    if (delegate && delegate.contextEntered) {\n        delegate.contextEntered(target, match);\n    }\n    callback(match);\n};\nfunction generateMatch(startingPath, matcher, delegate) {\n    function match(path, callback) {\n        var fullPath = startingPath + path;\n        if (callback) {\n            callback(generateMatch(fullPath, matcher, delegate));\n        }\n        else {\n            return new Target(fullPath, matcher, delegate);\n        }\n    }\n    \n    return match;\n}\nfunction addRoute(routeArray, path, handler) {\n    var len = 0;\n    for (var i = 0; i < routeArray.length; i++) {\n        len += routeArray[i].path.length;\n    }\n    path = path.substr(len);\n    var route = { path: path, handler: handler };\n    routeArray.push(route);\n}\nfunction eachRoute(baseRoute, matcher, callback, binding) {\n    var routes = matcher.routes;\n    var paths = Object.keys(routes);\n    for (var i = 0; i < paths.length; i++) {\n        var path = paths[i];\n        var routeArray = baseRoute.slice();\n        addRoute(routeArray, path, routes[path]);\n        var nested = matcher.children[path];\n        if (nested) {\n            eachRoute(routeArray, nested, callback, binding);\n        }\n        else {\n            callback.call(binding, routeArray);\n        }\n    }\n}\nvar map = function (callback, addRouteCallback) {\n    var matcher = new Matcher();\n    callback(generateMatch(\"\", matcher, this.delegate));\n    eachRoute([], matcher, function (routes) {\n        if (addRouteCallback) {\n            addRouteCallback(this, routes);\n        }\n        else {\n            this.add(routes);\n        }\n    }, this);\n};\n\n// Normalizes percent-encoded values in `path` to upper-case and decodes percent-encoded\n// values that are not reserved (i.e., unicode characters, emoji, etc). The reserved\n// chars are \"/\" and \"%\".\n// Safe to call multiple times on the same path.\n// Normalizes percent-encoded values in `path` to upper-case and decodes percent-encoded\nfunction normalizePath(path) {\n    return path.split(\"/\")\n        .map(normalizeSegment)\n        .join(\"/\");\n}\n// We want to ensure the characters \"%\" and \"/\" remain in percent-encoded\n// form when normalizing paths, so replace them with their encoded form after\n// decoding the rest of the path\nvar SEGMENT_RESERVED_CHARS = /%|\\//g;\nfunction normalizeSegment(segment) {\n    if (segment.length < 3 || segment.indexOf(\"%\") === -1)\n        { return segment; }\n    return decodeURIComponent(segment).replace(SEGMENT_RESERVED_CHARS, encodeURIComponent);\n}\n// We do not want to encode these characters when generating dynamic path segments\n// See https://tools.ietf.org/html/rfc3986#section-3.3\n// sub-delims: \"!\", \"$\", \"&\", \"'\", \"(\", \")\", \"*\", \"+\", \",\", \";\", \"=\"\n// others allowed by RFC 3986: \":\", \"@\"\n//\n// First encode the entire path segment, then decode any of the encoded special chars.\n//\n// The chars \"!\", \"'\", \"(\", \")\", \"*\" do not get changed by `encodeURIComponent`,\n// so the possible encoded chars are:\n// ['%24', '%26', '%2B', '%2C', '%3B', '%3D', '%3A', '%40'].\nvar PATH_SEGMENT_ENCODINGS = /%(?:2(?:4|6|B|C)|3(?:B|D|A)|40)/g;\nfunction encodePathSegment(str) {\n    return encodeURIComponent(str).replace(PATH_SEGMENT_ENCODINGS, decodeURIComponent);\n}\n\nvar escapeRegex = /(\\/|\\.|\\*|\\+|\\?|\\||\\(|\\)|\\[|\\]|\\{|\\}|\\\\)/g;\nvar isArray = Array.isArray;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction getParam(params, key) {\n    if (typeof params !== \"object\" || params === null) {\n        throw new Error(\"You must pass an object as the second argument to `generate`.\");\n    }\n    if (!hasOwnProperty.call(params, key)) {\n        throw new Error(\"You must provide param `\" + key + \"` to `generate`.\");\n    }\n    var value = params[key];\n    var str = typeof value === \"string\" ? value : \"\" + value;\n    if (str.length === 0) {\n        throw new Error(\"You must provide a param `\" + key + \"`.\");\n    }\n    return str;\n}\nvar eachChar = [];\neachChar[0 /* Static */] = function (segment, currentState) {\n    var state = currentState;\n    var value = segment.value;\n    for (var i = 0; i < value.length; i++) {\n        var ch = value.charCodeAt(i);\n        state = state.put(ch, false, false);\n    }\n    return state;\n};\neachChar[1 /* Dynamic */] = function (_, currentState) {\n    return currentState.put(47 /* SLASH */, true, true);\n};\neachChar[2 /* Star */] = function (_, currentState) {\n    return currentState.put(-1 /* ANY */, false, true);\n};\neachChar[4 /* Epsilon */] = function (_, currentState) {\n    return currentState;\n};\nvar regex = [];\nregex[0 /* Static */] = function (segment) {\n    return segment.value.replace(escapeRegex, \"\\\\$1\");\n};\nregex[1 /* Dynamic */] = function () {\n    return \"([^/]+)\";\n};\nregex[2 /* Star */] = function () {\n    return \"(.+)\";\n};\nregex[4 /* Epsilon */] = function () {\n    return \"\";\n};\nvar generate = [];\ngenerate[0 /* Static */] = function (segment) {\n    return segment.value;\n};\ngenerate[1 /* Dynamic */] = function (segment, params) {\n    var value = getParam(params, segment.value);\n    if (RouteRecognizer.ENCODE_AND_DECODE_PATH_SEGMENTS) {\n        return encodePathSegment(value);\n    }\n    else {\n        return value;\n    }\n};\ngenerate[2 /* Star */] = function (segment, params) {\n    return getParam(params, segment.value);\n};\ngenerate[4 /* Epsilon */] = function () {\n    return \"\";\n};\nvar EmptyObject = Object.freeze({});\nvar EmptyArray = Object.freeze([]);\n// The `names` will be populated with the paramter name for each dynamic/star\n// segment. `shouldDecodes` will be populated with a boolean for each dyanamic/star\n// segment, indicating whether it should be decoded during recognition.\nfunction parse(segments, route, types) {\n    // normalize route as not starting with a \"/\". Recognition will\n    // also normalize.\n    if (route.length > 0 && route.charCodeAt(0) === 47 /* SLASH */) {\n        route = route.substr(1);\n    }\n    var parts = route.split(\"/\");\n    var names = undefined;\n    var shouldDecodes = undefined;\n    for (var i = 0; i < parts.length; i++) {\n        var part = parts[i];\n        var flags = 0;\n        var type = 0;\n        if (part === \"\") {\n            type = 4 /* Epsilon */;\n        }\n        else if (part.charCodeAt(0) === 58 /* COLON */) {\n            type = 1 /* Dynamic */;\n        }\n        else if (part.charCodeAt(0) === 42 /* STAR */) {\n            type = 2 /* Star */;\n        }\n        else {\n            type = 0 /* Static */;\n        }\n        flags = 2 << type;\n        if (flags & 12 /* Named */) {\n            part = part.slice(1);\n            names = names || [];\n            names.push(part);\n            shouldDecodes = shouldDecodes || [];\n            shouldDecodes.push((flags & 4 /* Decoded */) !== 0);\n        }\n        if (flags & 14 /* Counted */) {\n            types[type]++;\n        }\n        segments.push({\n            type: type,\n            value: normalizeSegment(part)\n        });\n    }\n    return {\n        names: names || EmptyArray,\n        shouldDecodes: shouldDecodes || EmptyArray,\n    };\n}\nfunction isEqualCharSpec(spec, char, negate) {\n    return spec.char === char && spec.negate === negate;\n}\n// A State has a character specification and (`charSpec`) and a list of possible\n// subsequent states (`nextStates`).\n//\n// If a State is an accepting state, it will also have several additional\n// properties:\n//\n// * `regex`: A regular expression that is used to extract parameters from paths\n//   that reached this accepting state.\n// * `handlers`: Information on how to convert the list of captures into calls\n//   to registered handlers with the specified parameters\n// * `types`: How many static, dynamic or star segments in this route. Used to\n//   decide which route to use if multiple registered routes match a path.\n//\n// Currently, State is implemented naively by looping over `nextStates` and\n// comparing a character specification against a character. A more efficient\n// implementation would use a hash of keys pointing at one or more next states.\nvar State = function State(states, id, char, negate, repeat) {\n    this.states = states;\n    this.id = id;\n    this.char = char;\n    this.negate = negate;\n    this.nextStates = repeat ? id : null;\n    this.pattern = \"\";\n    this._regex = undefined;\n    this.handlers = undefined;\n    this.types = undefined;\n};\nState.prototype.regex = function regex$1 () {\n    if (!this._regex) {\n        this._regex = new RegExp(this.pattern);\n    }\n    return this._regex;\n};\nState.prototype.get = function get (char, negate) {\n        var this$1 = this;\n\n    var nextStates = this.nextStates;\n    if (nextStates === null)\n        { return; }\n    if (isArray(nextStates)) {\n        for (var i = 0; i < nextStates.length; i++) {\n            var child = this$1.states[nextStates[i]];\n            if (isEqualCharSpec(child, char, negate)) {\n                return child;\n            }\n        }\n    }\n    else {\n        var child$1 = this.states[nextStates];\n        if (isEqualCharSpec(child$1, char, negate)) {\n            return child$1;\n        }\n    }\n};\nState.prototype.put = function put (char, negate, repeat) {\n    var state;\n    // If the character specification already exists in a child of the current\n    // state, just return that state.\n    if (state = this.get(char, negate)) {\n        return state;\n    }\n    // Make a new state for the character spec\n    var states = this.states;\n    state = new State(states, states.length, char, negate, repeat);\n    states[states.length] = state;\n    // Insert the new state as a child of the current state\n    if (this.nextStates == null) {\n        this.nextStates = state.id;\n    }\n    else if (isArray(this.nextStates)) {\n        this.nextStates.push(state.id);\n    }\n    else {\n        this.nextStates = [this.nextStates, state.id];\n    }\n    // Return the new state\n    return state;\n};\n// Find a list of child states matching the next character\nState.prototype.match = function match (ch) {\n        var this$1 = this;\n\n    var nextStates = this.nextStates;\n    if (!nextStates)\n        { return []; }\n    var returned = [];\n    if (isArray(nextStates)) {\n        for (var i = 0; i < nextStates.length; i++) {\n            var child = this$1.states[nextStates[i]];\n            if (isMatch(child, ch)) {\n                returned.push(child);\n            }\n        }\n    }\n    else {\n        var child$1 = this.states[nextStates];\n        if (isMatch(child$1, ch)) {\n            returned.push(child$1);\n        }\n    }\n    return returned;\n};\nfunction isMatch(spec, char) {\n    return spec.negate ? spec.char !== char && spec.char !== -1 /* ANY */ : spec.char === char || spec.char === -1 /* ANY */;\n}\n// This is a somewhat naive strategy, but should work in a lot of cases\n// A better strategy would properly resolve /posts/:id/new and /posts/edit/:id.\n//\n// This strategy generally prefers more static and less dynamic matching.\n// Specifically, it\n//\n//  * prefers fewer stars to more, then\n//  * prefers using stars for less of the match to more, then\n//  * prefers fewer dynamic segments to more, then\n//  * prefers more static segments to more\nfunction sortSolutions(states) {\n    return states.sort(function (a, b) {\n        var ref = a.types || [0, 0, 0];\n        var astatics = ref[0];\n        var adynamics = ref[1];\n        var astars = ref[2];\n        var ref$1 = b.types || [0, 0, 0];\n        var bstatics = ref$1[0];\n        var bdynamics = ref$1[1];\n        var bstars = ref$1[2];\n        if (astars !== bstars) {\n            return astars - bstars;\n        }\n        if (astars) {\n            if (astatics !== bstatics) {\n                return bstatics - astatics;\n            }\n            if (adynamics !== bdynamics) {\n                return bdynamics - adynamics;\n            }\n        }\n        if (adynamics !== bdynamics) {\n            return adynamics - bdynamics;\n        }\n        if (astatics !== bstatics) {\n            return bstatics - astatics;\n        }\n        return 0;\n    });\n}\nfunction recognizeChar(states, ch) {\n    var nextStates = [];\n    for (var i = 0, l = states.length; i < l; i++) {\n        var state = states[i];\n        nextStates = nextStates.concat(state.match(ch));\n    }\n    return nextStates;\n}\nvar RecognizeResults = function RecognizeResults(queryParams) {\n    this.length = 0;\n    this.queryParams = queryParams || {};\n};\n\nRecognizeResults.prototype.splice = Array.prototype.splice;\nRecognizeResults.prototype.slice = Array.prototype.slice;\nRecognizeResults.prototype.push = Array.prototype.push;\nfunction findHandler(state, originalPath, queryParams) {\n    var handlers = state.handlers;\n    var regex = state.regex();\n    if (!regex || !handlers)\n        { throw new Error(\"state not initialized\"); }\n    var captures = originalPath.match(regex);\n    var currentCapture = 1;\n    var result = new RecognizeResults(queryParams);\n    result.length = handlers.length;\n    for (var i = 0; i < handlers.length; i++) {\n        var handler = handlers[i];\n        var names = handler.names;\n        var shouldDecodes = handler.shouldDecodes;\n        var params = EmptyObject;\n        var isDynamic = false;\n        if (names !== EmptyArray && shouldDecodes !== EmptyArray) {\n            for (var j = 0; j < names.length; j++) {\n                isDynamic = true;\n                var name = names[j];\n                var capture = captures && captures[currentCapture++];\n                if (params === EmptyObject) {\n                    params = {};\n                }\n                if (RouteRecognizer.ENCODE_AND_DECODE_PATH_SEGMENTS && shouldDecodes[j]) {\n                    params[name] = capture && decodeURIComponent(capture);\n                }\n                else {\n                    params[name] = capture;\n                }\n            }\n        }\n        result[i] = {\n            handler: handler.handler,\n            params: params,\n            isDynamic: isDynamic\n        };\n    }\n    return result;\n}\nfunction decodeQueryParamPart(part) {\n    // http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4.1\n    part = part.replace(/\\+/gm, \"%20\");\n    var result;\n    try {\n        result = decodeURIComponent(part);\n    }\n    catch (error) {\n        result = \"\";\n    }\n    return result;\n}\nvar RouteRecognizer = function RouteRecognizer() {\n    this.names = createMap();\n    var states = [];\n    var state = new State(states, 0, -1 /* ANY */, true, false);\n    states[0] = state;\n    this.states = states;\n    this.rootState = state;\n};\nRouteRecognizer.prototype.add = function add (routes, options) {\n    var currentState = this.rootState;\n    var pattern = \"^\";\n    var types = [0, 0, 0];\n    var handlers = new Array(routes.length);\n    var allSegments = [];\n    var isEmpty = true;\n    var j = 0;\n    for (var i = 0; i < routes.length; i++) {\n        var route = routes[i];\n        var ref = parse(allSegments, route.path, types);\n            var names = ref.names;\n            var shouldDecodes = ref.shouldDecodes;\n        // preserve j so it points to the start of newly added segments\n        for (; j < allSegments.length; j++) {\n            var segment = allSegments[j];\n            if (segment.type === 4 /* Epsilon */) {\n                continue;\n            }\n            isEmpty = false;\n            // Add a \"/\" for the new segment\n            currentState = currentState.put(47 /* SLASH */, false, false);\n            pattern += \"/\";\n            // Add a representation of the segment to the NFA and regex\n            currentState = eachChar[segment.type](segment, currentState);\n            pattern += regex[segment.type](segment);\n        }\n        handlers[i] = {\n            handler: route.handler,\n            names: names,\n            shouldDecodes: shouldDecodes\n        };\n    }\n    if (isEmpty) {\n        currentState = currentState.put(47 /* SLASH */, false, false);\n        pattern += \"/\";\n    }\n    currentState.handlers = handlers;\n    currentState.pattern = pattern + \"$\";\n    currentState.types = types;\n    var name;\n    if (typeof options === \"object\" && options !== null && options.as) {\n        name = options.as;\n    }\n    if (name) {\n        // if (this.names[name]) {\n        //   throw new Error(\"You may not add a duplicate route named `\" + name + \"`.\");\n        // }\n        this.names[name] = {\n            segments: allSegments,\n            handlers: handlers\n        };\n    }\n};\nRouteRecognizer.prototype.handlersFor = function handlersFor (name) {\n    var route = this.names[name];\n    if (!route) {\n        throw new Error(\"There is no route named \" + name);\n    }\n    var result = new Array(route.handlers.length);\n    for (var i = 0; i < route.handlers.length; i++) {\n        var handler = route.handlers[i];\n        result[i] = handler;\n    }\n    return result;\n};\nRouteRecognizer.prototype.hasRoute = function hasRoute (name) {\n    return !!this.names[name];\n};\nRouteRecognizer.prototype.generate = function generate$1 (name, params) {\n    var route = this.names[name];\n    var output = \"\";\n    if (!route) {\n        throw new Error(\"There is no route named \" + name);\n    }\n    var segments = route.segments;\n    for (var i = 0; i < segments.length; i++) {\n        var segment = segments[i];\n        if (segment.type === 4 /* Epsilon */) {\n            continue;\n        }\n        output += \"/\";\n        output += generate[segment.type](segment, params);\n    }\n    if (output.charAt(0) !== \"/\") {\n        output = \"/\" + output;\n    }\n    if (params && params.queryParams) {\n        output += this.generateQueryString(params.queryParams);\n    }\n    return output;\n};\nRouteRecognizer.prototype.generateQueryString = function generateQueryString (params) {\n    var pairs = [];\n    var keys = Object.keys(params);\n    keys.sort();\n    for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        var value = params[key];\n        if (value == null) {\n            continue;\n        }\n        var pair = encodeURIComponent(key);\n        if (isArray(value)) {\n            for (var j = 0; j < value.length; j++) {\n                var arrayPair = key + \"[]\" + \"=\" + encodeURIComponent(value[j]);\n                pairs.push(arrayPair);\n            }\n        }\n        else {\n            pair += \"=\" + encodeURIComponent(value);\n            pairs.push(pair);\n        }\n    }\n    if (pairs.length === 0) {\n        return \"\";\n    }\n    return \"?\" + pairs.join(\"&\");\n};\nRouteRecognizer.prototype.parseQueryString = function parseQueryString (queryString) {\n    var pairs = queryString.split(\"&\");\n    var queryParams = {};\n    for (var i = 0; i < pairs.length; i++) {\n        var pair = pairs[i].split(\"=\"), key = decodeQueryParamPart(pair[0]), keyLength = key.length, isArray = false, value = (void 0);\n        if (pair.length === 1) {\n            value = \"true\";\n        }\n        else {\n            // Handle arrays\n            if (keyLength > 2 && key.slice(keyLength - 2) === \"[]\") {\n                isArray = true;\n                key = key.slice(0, keyLength - 2);\n                if (!queryParams[key]) {\n                    queryParams[key] = [];\n                }\n            }\n            value = pair[1] ? decodeQueryParamPart(pair[1]) : \"\";\n        }\n        if (isArray) {\n            queryParams[key].push(value);\n        }\n        else {\n            queryParams[key] = value;\n        }\n    }\n    return queryParams;\n};\nRouteRecognizer.prototype.recognize = function recognize (path) {\n    var results;\n    var states = [this.rootState];\n    var queryParams = {};\n    var isSlashDropped = false;\n    var hashStart = path.indexOf(\"#\");\n    if (hashStart !== -1) {\n        path = path.substr(0, hashStart);\n    }\n    var queryStart = path.indexOf(\"?\");\n    if (queryStart !== -1) {\n        var queryString = path.substr(queryStart + 1, path.length);\n        path = path.substr(0, queryStart);\n        queryParams = this.parseQueryString(queryString);\n    }\n    if (path.charAt(0) !== \"/\") {\n        path = \"/\" + path;\n    }\n    var originalPath = path;\n    if (RouteRecognizer.ENCODE_AND_DECODE_PATH_SEGMENTS) {\n        path = normalizePath(path);\n    }\n    else {\n        path = decodeURI(path);\n        originalPath = decodeURI(originalPath);\n    }\n    var pathLen = path.length;\n    if (pathLen > 1 && path.charAt(pathLen - 1) === \"/\") {\n        path = path.substr(0, pathLen - 1);\n        originalPath = originalPath.substr(0, originalPath.length - 1);\n        isSlashDropped = true;\n    }\n    for (var i = 0; i < path.length; i++) {\n        states = recognizeChar(states, path.charCodeAt(i));\n        if (!states.length) {\n            break;\n        }\n    }\n    var solutions = [];\n    for (var i$1 = 0; i$1 < states.length; i$1++) {\n        if (states[i$1].handlers) {\n            solutions.push(states[i$1]);\n        }\n    }\n    states = sortSolutions(solutions);\n    var state = solutions[0];\n    if (state && state.handlers) {\n        // if a trailing slash was dropped and a star segment is the last segment\n        // specified, put the trailing slash back\n        if (isSlashDropped && state.pattern && state.pattern.slice(-5) === \"(.+)$\") {\n            originalPath = originalPath + \"/\";\n        }\n        results = findHandler(state, originalPath, queryParams);\n    }\n    return results;\n};\nRouteRecognizer.VERSION = \"0.3.4\";\n// Set to false to opt-out of encoding and decoding path segments.\n// See https://github.com/tildeio/route-recognizer/pull/55\nRouteRecognizer.ENCODE_AND_DECODE_PATH_SEGMENTS = true;\nRouteRecognizer.Normalizer = {\n    normalizeSegment: normalizeSegment, normalizePath: normalizePath, encodePathSegment: encodePathSegment\n};\nRouteRecognizer.prototype.map = map;\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RouteRecognizer);\n\n//# sourceMappingURL=route-recognizer.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcm91dGUtcmVjb2duaXplci9kaXN0L3JvdXRlLXJlY29nbml6ZXIuZXMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9EQUFvRCxHQUFHO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsd0JBQXdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0JBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLGVBQWUsRUFBQzs7QUFFL0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZXN0YXBwLy4vbm9kZV9tb2R1bGVzL3JvdXRlLXJlY29nbml6ZXIvZGlzdC9yb3V0ZS1yZWNvZ25pemVyLmVzLmpzPzFhZjIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGNyZWF0ZU9iamVjdCA9IE9iamVjdC5jcmVhdGU7XG5mdW5jdGlvbiBjcmVhdGVNYXAoKSB7XG4gICAgdmFyIG1hcCA9IGNyZWF0ZU9iamVjdChudWxsKTtcbiAgICBtYXBbXCJfX1wiXSA9IHVuZGVmaW5lZDtcbiAgICBkZWxldGUgbWFwW1wiX19cIl07XG4gICAgcmV0dXJuIG1hcDtcbn1cblxudmFyIFRhcmdldCA9IGZ1bmN0aW9uIFRhcmdldChwYXRoLCBtYXRjaGVyLCBkZWxlZ2F0ZSkge1xuICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgdGhpcy5tYXRjaGVyID0gbWF0Y2hlcjtcbiAgICB0aGlzLmRlbGVnYXRlID0gZGVsZWdhdGU7XG59O1xuVGFyZ2V0LnByb3RvdHlwZS50byA9IGZ1bmN0aW9uIHRvICh0YXJnZXQsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGRlbGVnYXRlID0gdGhpcy5kZWxlZ2F0ZTtcbiAgICBpZiAoZGVsZWdhdGUgJiYgZGVsZWdhdGUud2lsbEFkZFJvdXRlKSB7XG4gICAgICAgIHRhcmdldCA9IGRlbGVnYXRlLndpbGxBZGRSb3V0ZSh0aGlzLm1hdGNoZXIudGFyZ2V0LCB0YXJnZXQpO1xuICAgIH1cbiAgICB0aGlzLm1hdGNoZXIuYWRkKHRoaXMucGF0aCwgdGFyZ2V0KTtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IG11c3QgaGF2ZSBhbiBhcmd1bWVudCBpbiB0aGUgZnVuY3Rpb24gcGFzc2VkIHRvIGB0b2BcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXRjaGVyLmFkZENoaWxkKHRoaXMucGF0aCwgdGFyZ2V0LCBjYWxsYmFjaywgdGhpcy5kZWxlZ2F0ZSk7XG4gICAgfVxufTtcbnZhciBNYXRjaGVyID0gZnVuY3Rpb24gTWF0Y2hlcih0YXJnZXQpIHtcbiAgICB0aGlzLnJvdXRlcyA9IGNyZWF0ZU1hcCgpO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBjcmVhdGVNYXAoKTtcbiAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbn07XG5NYXRjaGVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKHBhdGgsIHRhcmdldCkge1xuICAgIHRoaXMucm91dGVzW3BhdGhdID0gdGFyZ2V0O1xufTtcbk1hdGNoZXIucHJvdG90eXBlLmFkZENoaWxkID0gZnVuY3Rpb24gYWRkQ2hpbGQgKHBhdGgsIHRhcmdldCwgY2FsbGJhY2ssIGRlbGVnYXRlKSB7XG4gICAgdmFyIG1hdGNoZXIgPSBuZXcgTWF0Y2hlcih0YXJnZXQpO1xuICAgIHRoaXMuY2hpbGRyZW5bcGF0aF0gPSBtYXRjaGVyO1xuICAgIHZhciBtYXRjaCA9IGdlbmVyYXRlTWF0Y2gocGF0aCwgbWF0Y2hlciwgZGVsZWdhdGUpO1xuICAgIGlmIChkZWxlZ2F0ZSAmJiBkZWxlZ2F0ZS5jb250ZXh0RW50ZXJlZCkge1xuICAgICAgICBkZWxlZ2F0ZS5jb250ZXh0RW50ZXJlZCh0YXJnZXQsIG1hdGNoKTtcbiAgICB9XG4gICAgY2FsbGJhY2sobWF0Y2gpO1xufTtcbmZ1bmN0aW9uIGdlbmVyYXRlTWF0Y2goc3RhcnRpbmdQYXRoLCBtYXRjaGVyLCBkZWxlZ2F0ZSkge1xuICAgIGZ1bmN0aW9uIG1hdGNoKHBhdGgsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBmdWxsUGF0aCA9IHN0YXJ0aW5nUGF0aCArIHBhdGg7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2soZ2VuZXJhdGVNYXRjaChmdWxsUGF0aCwgbWF0Y2hlciwgZGVsZWdhdGUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGFyZ2V0KGZ1bGxQYXRoLCBtYXRjaGVyLCBkZWxlZ2F0ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG1hdGNoO1xufVxuZnVuY3Rpb24gYWRkUm91dGUocm91dGVBcnJheSwgcGF0aCwgaGFuZGxlcikge1xuICAgIHZhciBsZW4gPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm91dGVBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZW4gKz0gcm91dGVBcnJheVtpXS5wYXRoLmxlbmd0aDtcbiAgICB9XG4gICAgcGF0aCA9IHBhdGguc3Vic3RyKGxlbik7XG4gICAgdmFyIHJvdXRlID0geyBwYXRoOiBwYXRoLCBoYW5kbGVyOiBoYW5kbGVyIH07XG4gICAgcm91dGVBcnJheS5wdXNoKHJvdXRlKTtcbn1cbmZ1bmN0aW9uIGVhY2hSb3V0ZShiYXNlUm91dGUsIG1hdGNoZXIsIGNhbGxiYWNrLCBiaW5kaW5nKSB7XG4gICAgdmFyIHJvdXRlcyA9IG1hdGNoZXIucm91dGVzO1xuICAgIHZhciBwYXRocyA9IE9iamVjdC5rZXlzKHJvdXRlcyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRocy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcGF0aCA9IHBhdGhzW2ldO1xuICAgICAgICB2YXIgcm91dGVBcnJheSA9IGJhc2VSb3V0ZS5zbGljZSgpO1xuICAgICAgICBhZGRSb3V0ZShyb3V0ZUFycmF5LCBwYXRoLCByb3V0ZXNbcGF0aF0pO1xuICAgICAgICB2YXIgbmVzdGVkID0gbWF0Y2hlci5jaGlsZHJlbltwYXRoXTtcbiAgICAgICAgaWYgKG5lc3RlZCkge1xuICAgICAgICAgICAgZWFjaFJvdXRlKHJvdXRlQXJyYXksIG5lc3RlZCwgY2FsbGJhY2ssIGJpbmRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2suY2FsbChiaW5kaW5nLCByb3V0ZUFycmF5KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbnZhciBtYXAgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGFkZFJvdXRlQ2FsbGJhY2spIHtcbiAgICB2YXIgbWF0Y2hlciA9IG5ldyBNYXRjaGVyKCk7XG4gICAgY2FsbGJhY2soZ2VuZXJhdGVNYXRjaChcIlwiLCBtYXRjaGVyLCB0aGlzLmRlbGVnYXRlKSk7XG4gICAgZWFjaFJvdXRlKFtdLCBtYXRjaGVyLCBmdW5jdGlvbiAocm91dGVzKSB7XG4gICAgICAgIGlmIChhZGRSb3V0ZUNhbGxiYWNrKSB7XG4gICAgICAgICAgICBhZGRSb3V0ZUNhbGxiYWNrKHRoaXMsIHJvdXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFkZChyb3V0ZXMpO1xuICAgICAgICB9XG4gICAgfSwgdGhpcyk7XG59O1xuXG4vLyBOb3JtYWxpemVzIHBlcmNlbnQtZW5jb2RlZCB2YWx1ZXMgaW4gYHBhdGhgIHRvIHVwcGVyLWNhc2UgYW5kIGRlY29kZXMgcGVyY2VudC1lbmNvZGVkXG4vLyB2YWx1ZXMgdGhhdCBhcmUgbm90IHJlc2VydmVkIChpLmUuLCB1bmljb2RlIGNoYXJhY3RlcnMsIGVtb2ppLCBldGMpLiBUaGUgcmVzZXJ2ZWRcbi8vIGNoYXJzIGFyZSBcIi9cIiBhbmQgXCIlXCIuXG4vLyBTYWZlIHRvIGNhbGwgbXVsdGlwbGUgdGltZXMgb24gdGhlIHNhbWUgcGF0aC5cbi8vIE5vcm1hbGl6ZXMgcGVyY2VudC1lbmNvZGVkIHZhbHVlcyBpbiBgcGF0aGAgdG8gdXBwZXItY2FzZSBhbmQgZGVjb2RlcyBwZXJjZW50LWVuY29kZWRcbmZ1bmN0aW9uIG5vcm1hbGl6ZVBhdGgocGF0aCkge1xuICAgIHJldHVybiBwYXRoLnNwbGl0KFwiL1wiKVxuICAgICAgICAubWFwKG5vcm1hbGl6ZVNlZ21lbnQpXG4gICAgICAgIC5qb2luKFwiL1wiKTtcbn1cbi8vIFdlIHdhbnQgdG8gZW5zdXJlIHRoZSBjaGFyYWN0ZXJzIFwiJVwiIGFuZCBcIi9cIiByZW1haW4gaW4gcGVyY2VudC1lbmNvZGVkXG4vLyBmb3JtIHdoZW4gbm9ybWFsaXppbmcgcGF0aHMsIHNvIHJlcGxhY2UgdGhlbSB3aXRoIHRoZWlyIGVuY29kZWQgZm9ybSBhZnRlclxuLy8gZGVjb2RpbmcgdGhlIHJlc3Qgb2YgdGhlIHBhdGhcbnZhciBTRUdNRU5UX1JFU0VSVkVEX0NIQVJTID0gLyV8XFwvL2c7XG5mdW5jdGlvbiBub3JtYWxpemVTZWdtZW50KHNlZ21lbnQpIHtcbiAgICBpZiAoc2VnbWVudC5sZW5ndGggPCAzIHx8IHNlZ21lbnQuaW5kZXhPZihcIiVcIikgPT09IC0xKVxuICAgICAgICB7IHJldHVybiBzZWdtZW50OyB9XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzZWdtZW50KS5yZXBsYWNlKFNFR01FTlRfUkVTRVJWRURfQ0hBUlMsIGVuY29kZVVSSUNvbXBvbmVudCk7XG59XG4vLyBXZSBkbyBub3Qgd2FudCB0byBlbmNvZGUgdGhlc2UgY2hhcmFjdGVycyB3aGVuIGdlbmVyYXRpbmcgZHluYW1pYyBwYXRoIHNlZ21lbnRzXG4vLyBTZWUgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM5ODYjc2VjdGlvbi0zLjNcbi8vIHN1Yi1kZWxpbXM6IFwiIVwiLCBcIiRcIiwgXCImXCIsIFwiJ1wiLCBcIihcIiwgXCIpXCIsIFwiKlwiLCBcIitcIiwgXCIsXCIsIFwiO1wiLCBcIj1cIlxuLy8gb3RoZXJzIGFsbG93ZWQgYnkgUkZDIDM5ODY6IFwiOlwiLCBcIkBcIlxuLy9cbi8vIEZpcnN0IGVuY29kZSB0aGUgZW50aXJlIHBhdGggc2VnbWVudCwgdGhlbiBkZWNvZGUgYW55IG9mIHRoZSBlbmNvZGVkIHNwZWNpYWwgY2hhcnMuXG4vL1xuLy8gVGhlIGNoYXJzIFwiIVwiLCBcIidcIiwgXCIoXCIsIFwiKVwiLCBcIipcIiBkbyBub3QgZ2V0IGNoYW5nZWQgYnkgYGVuY29kZVVSSUNvbXBvbmVudGAsXG4vLyBzbyB0aGUgcG9zc2libGUgZW5jb2RlZCBjaGFycyBhcmU6XG4vLyBbJyUyNCcsICclMjYnLCAnJTJCJywgJyUyQycsICclM0InLCAnJTNEJywgJyUzQScsICclNDAnXS5cbnZhciBQQVRIX1NFR01FTlRfRU5DT0RJTkdTID0gLyUoPzoyKD86NHw2fEJ8Qyl8Myg/OkJ8RHxBKXw0MCkvZztcbmZ1bmN0aW9uIGVuY29kZVBhdGhTZWdtZW50KHN0cikge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyKS5yZXBsYWNlKFBBVEhfU0VHTUVOVF9FTkNPRElOR1MsIGRlY29kZVVSSUNvbXBvbmVudCk7XG59XG5cbnZhciBlc2NhcGVSZWdleCA9IC8oXFwvfFxcLnxcXCp8XFwrfFxcP3xcXHx8XFwofFxcKXxcXFt8XFxdfFxce3xcXH18XFxcXCkvZztcbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBnZXRQYXJhbShwYXJhbXMsIGtleSkge1xuICAgIGlmICh0eXBlb2YgcGFyYW1zICE9PSBcIm9iamVjdFwiIHx8IHBhcmFtcyA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgbXVzdCBwYXNzIGFuIG9iamVjdCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGBnZW5lcmF0ZWAuXCIpO1xuICAgIH1cbiAgICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwocGFyYW1zLCBrZXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBtdXN0IHByb3ZpZGUgcGFyYW0gYFwiICsga2V5ICsgXCJgIHRvIGBnZW5lcmF0ZWAuXCIpO1xuICAgIH1cbiAgICB2YXIgdmFsdWUgPSBwYXJhbXNba2V5XTtcbiAgICB2YXIgc3RyID0gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiID8gdmFsdWUgOiBcIlwiICsgdmFsdWU7XG4gICAgaWYgKHN0ci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IG11c3QgcHJvdmlkZSBhIHBhcmFtIGBcIiArIGtleSArIFwiYC5cIik7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59XG52YXIgZWFjaENoYXIgPSBbXTtcbmVhY2hDaGFyWzAgLyogU3RhdGljICovXSA9IGZ1bmN0aW9uIChzZWdtZW50LCBjdXJyZW50U3RhdGUpIHtcbiAgICB2YXIgc3RhdGUgPSBjdXJyZW50U3RhdGU7XG4gICAgdmFyIHZhbHVlID0gc2VnbWVudC52YWx1ZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaCA9IHZhbHVlLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIHN0YXRlID0gc3RhdGUucHV0KGNoLCBmYWxzZSwgZmFsc2UpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGU7XG59O1xuZWFjaENoYXJbMSAvKiBEeW5hbWljICovXSA9IGZ1bmN0aW9uIChfLCBjdXJyZW50U3RhdGUpIHtcbiAgICByZXR1cm4gY3VycmVudFN0YXRlLnB1dCg0NyAvKiBTTEFTSCAqLywgdHJ1ZSwgdHJ1ZSk7XG59O1xuZWFjaENoYXJbMiAvKiBTdGFyICovXSA9IGZ1bmN0aW9uIChfLCBjdXJyZW50U3RhdGUpIHtcbiAgICByZXR1cm4gY3VycmVudFN0YXRlLnB1dCgtMSAvKiBBTlkgKi8sIGZhbHNlLCB0cnVlKTtcbn07XG5lYWNoQ2hhcls0IC8qIEVwc2lsb24gKi9dID0gZnVuY3Rpb24gKF8sIGN1cnJlbnRTdGF0ZSkge1xuICAgIHJldHVybiBjdXJyZW50U3RhdGU7XG59O1xudmFyIHJlZ2V4ID0gW107XG5yZWdleFswIC8qIFN0YXRpYyAqL10gPSBmdW5jdGlvbiAoc2VnbWVudCkge1xuICAgIHJldHVybiBzZWdtZW50LnZhbHVlLnJlcGxhY2UoZXNjYXBlUmVnZXgsIFwiXFxcXCQxXCIpO1xufTtcbnJlZ2V4WzEgLyogRHluYW1pYyAqL10gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFwiKFteL10rKVwiO1xufTtcbnJlZ2V4WzIgLyogU3RhciAqL10gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFwiKC4rKVwiO1xufTtcbnJlZ2V4WzQgLyogRXBzaWxvbiAqL10gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFwiXCI7XG59O1xudmFyIGdlbmVyYXRlID0gW107XG5nZW5lcmF0ZVswIC8qIFN0YXRpYyAqL10gPSBmdW5jdGlvbiAoc2VnbWVudCkge1xuICAgIHJldHVybiBzZWdtZW50LnZhbHVlO1xufTtcbmdlbmVyYXRlWzEgLyogRHluYW1pYyAqL10gPSBmdW5jdGlvbiAoc2VnbWVudCwgcGFyYW1zKSB7XG4gICAgdmFyIHZhbHVlID0gZ2V0UGFyYW0ocGFyYW1zLCBzZWdtZW50LnZhbHVlKTtcbiAgICBpZiAoUm91dGVSZWNvZ25pemVyLkVOQ09ERV9BTkRfREVDT0RFX1BBVEhfU0VHTUVOVFMpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZVBhdGhTZWdtZW50KHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59O1xuZ2VuZXJhdGVbMiAvKiBTdGFyICovXSA9IGZ1bmN0aW9uIChzZWdtZW50LCBwYXJhbXMpIHtcbiAgICByZXR1cm4gZ2V0UGFyYW0ocGFyYW1zLCBzZWdtZW50LnZhbHVlKTtcbn07XG5nZW5lcmF0ZVs0IC8qIEVwc2lsb24gKi9dID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBcIlwiO1xufTtcbnZhciBFbXB0eU9iamVjdCA9IE9iamVjdC5mcmVlemUoe30pO1xudmFyIEVtcHR5QXJyYXkgPSBPYmplY3QuZnJlZXplKFtdKTtcbi8vIFRoZSBgbmFtZXNgIHdpbGwgYmUgcG9wdWxhdGVkIHdpdGggdGhlIHBhcmFtdGVyIG5hbWUgZm9yIGVhY2ggZHluYW1pYy9zdGFyXG4vLyBzZWdtZW50LiBgc2hvdWxkRGVjb2Rlc2Agd2lsbCBiZSBwb3B1bGF0ZWQgd2l0aCBhIGJvb2xlYW4gZm9yIGVhY2ggZHlhbmFtaWMvc3RhclxuLy8gc2VnbWVudCwgaW5kaWNhdGluZyB3aGV0aGVyIGl0IHNob3VsZCBiZSBkZWNvZGVkIGR1cmluZyByZWNvZ25pdGlvbi5cbmZ1bmN0aW9uIHBhcnNlKHNlZ21lbnRzLCByb3V0ZSwgdHlwZXMpIHtcbiAgICAvLyBub3JtYWxpemUgcm91dGUgYXMgbm90IHN0YXJ0aW5nIHdpdGggYSBcIi9cIi4gUmVjb2duaXRpb24gd2lsbFxuICAgIC8vIGFsc28gbm9ybWFsaXplLlxuICAgIGlmIChyb3V0ZS5sZW5ndGggPiAwICYmIHJvdXRlLmNoYXJDb2RlQXQoMCkgPT09IDQ3IC8qIFNMQVNIICovKSB7XG4gICAgICAgIHJvdXRlID0gcm91dGUuc3Vic3RyKDEpO1xuICAgIH1cbiAgICB2YXIgcGFydHMgPSByb3V0ZS5zcGxpdChcIi9cIik7XG4gICAgdmFyIG5hbWVzID0gdW5kZWZpbmVkO1xuICAgIHZhciBzaG91bGREZWNvZGVzID0gdW5kZWZpbmVkO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcnQgPSBwYXJ0c1tpXTtcbiAgICAgICAgdmFyIGZsYWdzID0gMDtcbiAgICAgICAgdmFyIHR5cGUgPSAwO1xuICAgICAgICBpZiAocGFydCA9PT0gXCJcIikge1xuICAgICAgICAgICAgdHlwZSA9IDQgLyogRXBzaWxvbiAqLztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXJ0LmNoYXJDb2RlQXQoMCkgPT09IDU4IC8qIENPTE9OICovKSB7XG4gICAgICAgICAgICB0eXBlID0gMSAvKiBEeW5hbWljICovO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhcnQuY2hhckNvZGVBdCgwKSA9PT0gNDIgLyogU1RBUiAqLykge1xuICAgICAgICAgICAgdHlwZSA9IDIgLyogU3RhciAqLztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHR5cGUgPSAwIC8qIFN0YXRpYyAqLztcbiAgICAgICAgfVxuICAgICAgICBmbGFncyA9IDIgPDwgdHlwZTtcbiAgICAgICAgaWYgKGZsYWdzICYgMTIgLyogTmFtZWQgKi8pIHtcbiAgICAgICAgICAgIHBhcnQgPSBwYXJ0LnNsaWNlKDEpO1xuICAgICAgICAgICAgbmFtZXMgPSBuYW1lcyB8fCBbXTtcbiAgICAgICAgICAgIG5hbWVzLnB1c2gocGFydCk7XG4gICAgICAgICAgICBzaG91bGREZWNvZGVzID0gc2hvdWxkRGVjb2RlcyB8fCBbXTtcbiAgICAgICAgICAgIHNob3VsZERlY29kZXMucHVzaCgoZmxhZ3MgJiA0IC8qIERlY29kZWQgKi8pICE9PSAwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmxhZ3MgJiAxNCAvKiBDb3VudGVkICovKSB7XG4gICAgICAgICAgICB0eXBlc1t0eXBlXSsrO1xuICAgICAgICB9XG4gICAgICAgIHNlZ21lbnRzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIHZhbHVlOiBub3JtYWxpemVTZWdtZW50KHBhcnQpXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lczogbmFtZXMgfHwgRW1wdHlBcnJheSxcbiAgICAgICAgc2hvdWxkRGVjb2Rlczogc2hvdWxkRGVjb2RlcyB8fCBFbXB0eUFycmF5LFxuICAgIH07XG59XG5mdW5jdGlvbiBpc0VxdWFsQ2hhclNwZWMoc3BlYywgY2hhciwgbmVnYXRlKSB7XG4gICAgcmV0dXJuIHNwZWMuY2hhciA9PT0gY2hhciAmJiBzcGVjLm5lZ2F0ZSA9PT0gbmVnYXRlO1xufVxuLy8gQSBTdGF0ZSBoYXMgYSBjaGFyYWN0ZXIgc3BlY2lmaWNhdGlvbiBhbmQgKGBjaGFyU3BlY2ApIGFuZCBhIGxpc3Qgb2YgcG9zc2libGVcbi8vIHN1YnNlcXVlbnQgc3RhdGVzIChgbmV4dFN0YXRlc2ApLlxuLy9cbi8vIElmIGEgU3RhdGUgaXMgYW4gYWNjZXB0aW5nIHN0YXRlLCBpdCB3aWxsIGFsc28gaGF2ZSBzZXZlcmFsIGFkZGl0aW9uYWxcbi8vIHByb3BlcnRpZXM6XG4vL1xuLy8gKiBgcmVnZXhgOiBBIHJlZ3VsYXIgZXhwcmVzc2lvbiB0aGF0IGlzIHVzZWQgdG8gZXh0cmFjdCBwYXJhbWV0ZXJzIGZyb20gcGF0aHNcbi8vICAgdGhhdCByZWFjaGVkIHRoaXMgYWNjZXB0aW5nIHN0YXRlLlxuLy8gKiBgaGFuZGxlcnNgOiBJbmZvcm1hdGlvbiBvbiBob3cgdG8gY29udmVydCB0aGUgbGlzdCBvZiBjYXB0dXJlcyBpbnRvIGNhbGxzXG4vLyAgIHRvIHJlZ2lzdGVyZWQgaGFuZGxlcnMgd2l0aCB0aGUgc3BlY2lmaWVkIHBhcmFtZXRlcnNcbi8vICogYHR5cGVzYDogSG93IG1hbnkgc3RhdGljLCBkeW5hbWljIG9yIHN0YXIgc2VnbWVudHMgaW4gdGhpcyByb3V0ZS4gVXNlZCB0b1xuLy8gICBkZWNpZGUgd2hpY2ggcm91dGUgdG8gdXNlIGlmIG11bHRpcGxlIHJlZ2lzdGVyZWQgcm91dGVzIG1hdGNoIGEgcGF0aC5cbi8vXG4vLyBDdXJyZW50bHksIFN0YXRlIGlzIGltcGxlbWVudGVkIG5haXZlbHkgYnkgbG9vcGluZyBvdmVyIGBuZXh0U3RhdGVzYCBhbmRcbi8vIGNvbXBhcmluZyBhIGNoYXJhY3RlciBzcGVjaWZpY2F0aW9uIGFnYWluc3QgYSBjaGFyYWN0ZXIuIEEgbW9yZSBlZmZpY2llbnRcbi8vIGltcGxlbWVudGF0aW9uIHdvdWxkIHVzZSBhIGhhc2ggb2Yga2V5cyBwb2ludGluZyBhdCBvbmUgb3IgbW9yZSBuZXh0IHN0YXRlcy5cbnZhciBTdGF0ZSA9IGZ1bmN0aW9uIFN0YXRlKHN0YXRlcywgaWQsIGNoYXIsIG5lZ2F0ZSwgcmVwZWF0KSB7XG4gICAgdGhpcy5zdGF0ZXMgPSBzdGF0ZXM7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMuY2hhciA9IGNoYXI7XG4gICAgdGhpcy5uZWdhdGUgPSBuZWdhdGU7XG4gICAgdGhpcy5uZXh0U3RhdGVzID0gcmVwZWF0ID8gaWQgOiBudWxsO1xuICAgIHRoaXMucGF0dGVybiA9IFwiXCI7XG4gICAgdGhpcy5fcmVnZXggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5oYW5kbGVycyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnR5cGVzID0gdW5kZWZpbmVkO1xufTtcblN0YXRlLnByb3RvdHlwZS5yZWdleCA9IGZ1bmN0aW9uIHJlZ2V4JDEgKCkge1xuICAgIGlmICghdGhpcy5fcmVnZXgpIHtcbiAgICAgICAgdGhpcy5fcmVnZXggPSBuZXcgUmVnRXhwKHRoaXMucGF0dGVybik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZWdleDtcbn07XG5TdGF0ZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChjaGFyLCBuZWdhdGUpIHtcbiAgICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgbmV4dFN0YXRlcyA9IHRoaXMubmV4dFN0YXRlcztcbiAgICBpZiAobmV4dFN0YXRlcyA9PT0gbnVsbClcbiAgICAgICAgeyByZXR1cm47IH1cbiAgICBpZiAoaXNBcnJheShuZXh0U3RhdGVzKSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5leHRTdGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMkMS5zdGF0ZXNbbmV4dFN0YXRlc1tpXV07XG4gICAgICAgICAgICBpZiAoaXNFcXVhbENoYXJTcGVjKGNoaWxkLCBjaGFyLCBuZWdhdGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgY2hpbGQkMSA9IHRoaXMuc3RhdGVzW25leHRTdGF0ZXNdO1xuICAgICAgICBpZiAoaXNFcXVhbENoYXJTcGVjKGNoaWxkJDEsIGNoYXIsIG5lZ2F0ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZCQxO1xuICAgICAgICB9XG4gICAgfVxufTtcblN0YXRlLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiBwdXQgKGNoYXIsIG5lZ2F0ZSwgcmVwZWF0KSB7XG4gICAgdmFyIHN0YXRlO1xuICAgIC8vIElmIHRoZSBjaGFyYWN0ZXIgc3BlY2lmaWNhdGlvbiBhbHJlYWR5IGV4aXN0cyBpbiBhIGNoaWxkIG9mIHRoZSBjdXJyZW50XG4gICAgLy8gc3RhdGUsIGp1c3QgcmV0dXJuIHRoYXQgc3RhdGUuXG4gICAgaWYgKHN0YXRlID0gdGhpcy5nZXQoY2hhciwgbmVnYXRlKSkge1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgIC8vIE1ha2UgYSBuZXcgc3RhdGUgZm9yIHRoZSBjaGFyYWN0ZXIgc3BlY1xuICAgIHZhciBzdGF0ZXMgPSB0aGlzLnN0YXRlcztcbiAgICBzdGF0ZSA9IG5ldyBTdGF0ZShzdGF0ZXMsIHN0YXRlcy5sZW5ndGgsIGNoYXIsIG5lZ2F0ZSwgcmVwZWF0KTtcbiAgICBzdGF0ZXNbc3RhdGVzLmxlbmd0aF0gPSBzdGF0ZTtcbiAgICAvLyBJbnNlcnQgdGhlIG5ldyBzdGF0ZSBhcyBhIGNoaWxkIG9mIHRoZSBjdXJyZW50IHN0YXRlXG4gICAgaWYgKHRoaXMubmV4dFN0YXRlcyA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMubmV4dFN0YXRlcyA9IHN0YXRlLmlkO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0FycmF5KHRoaXMubmV4dFN0YXRlcykpIHtcbiAgICAgICAgdGhpcy5uZXh0U3RhdGVzLnB1c2goc3RhdGUuaWQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5uZXh0U3RhdGVzID0gW3RoaXMubmV4dFN0YXRlcywgc3RhdGUuaWRdO1xuICAgIH1cbiAgICAvLyBSZXR1cm4gdGhlIG5ldyBzdGF0ZVxuICAgIHJldHVybiBzdGF0ZTtcbn07XG4vLyBGaW5kIGEgbGlzdCBvZiBjaGlsZCBzdGF0ZXMgbWF0Y2hpbmcgdGhlIG5leHQgY2hhcmFjdGVyXG5TdGF0ZS5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbiBtYXRjaCAoY2gpIHtcbiAgICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgbmV4dFN0YXRlcyA9IHRoaXMubmV4dFN0YXRlcztcbiAgICBpZiAoIW5leHRTdGF0ZXMpXG4gICAgICAgIHsgcmV0dXJuIFtdOyB9XG4gICAgdmFyIHJldHVybmVkID0gW107XG4gICAgaWYgKGlzQXJyYXkobmV4dFN0YXRlcykpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXh0U3RhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzJDEuc3RhdGVzW25leHRTdGF0ZXNbaV1dO1xuICAgICAgICAgICAgaWYgKGlzTWF0Y2goY2hpbGQsIGNoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybmVkLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgY2hpbGQkMSA9IHRoaXMuc3RhdGVzW25leHRTdGF0ZXNdO1xuICAgICAgICBpZiAoaXNNYXRjaChjaGlsZCQxLCBjaCkpIHtcbiAgICAgICAgICAgIHJldHVybmVkLnB1c2goY2hpbGQkMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldHVybmVkO1xufTtcbmZ1bmN0aW9uIGlzTWF0Y2goc3BlYywgY2hhcikge1xuICAgIHJldHVybiBzcGVjLm5lZ2F0ZSA/IHNwZWMuY2hhciAhPT0gY2hhciAmJiBzcGVjLmNoYXIgIT09IC0xIC8qIEFOWSAqLyA6IHNwZWMuY2hhciA9PT0gY2hhciB8fCBzcGVjLmNoYXIgPT09IC0xIC8qIEFOWSAqLztcbn1cbi8vIFRoaXMgaXMgYSBzb21ld2hhdCBuYWl2ZSBzdHJhdGVneSwgYnV0IHNob3VsZCB3b3JrIGluIGEgbG90IG9mIGNhc2VzXG4vLyBBIGJldHRlciBzdHJhdGVneSB3b3VsZCBwcm9wZXJseSByZXNvbHZlIC9wb3N0cy86aWQvbmV3IGFuZCAvcG9zdHMvZWRpdC86aWQuXG4vL1xuLy8gVGhpcyBzdHJhdGVneSBnZW5lcmFsbHkgcHJlZmVycyBtb3JlIHN0YXRpYyBhbmQgbGVzcyBkeW5hbWljIG1hdGNoaW5nLlxuLy8gU3BlY2lmaWNhbGx5LCBpdFxuLy9cbi8vICAqIHByZWZlcnMgZmV3ZXIgc3RhcnMgdG8gbW9yZSwgdGhlblxuLy8gICogcHJlZmVycyB1c2luZyBzdGFycyBmb3IgbGVzcyBvZiB0aGUgbWF0Y2ggdG8gbW9yZSwgdGhlblxuLy8gICogcHJlZmVycyBmZXdlciBkeW5hbWljIHNlZ21lbnRzIHRvIG1vcmUsIHRoZW5cbi8vICAqIHByZWZlcnMgbW9yZSBzdGF0aWMgc2VnbWVudHMgdG8gbW9yZVxuZnVuY3Rpb24gc29ydFNvbHV0aW9ucyhzdGF0ZXMpIHtcbiAgICByZXR1cm4gc3RhdGVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIHJlZiA9IGEudHlwZXMgfHwgWzAsIDAsIDBdO1xuICAgICAgICB2YXIgYXN0YXRpY3MgPSByZWZbMF07XG4gICAgICAgIHZhciBhZHluYW1pY3MgPSByZWZbMV07XG4gICAgICAgIHZhciBhc3RhcnMgPSByZWZbMl07XG4gICAgICAgIHZhciByZWYkMSA9IGIudHlwZXMgfHwgWzAsIDAsIDBdO1xuICAgICAgICB2YXIgYnN0YXRpY3MgPSByZWYkMVswXTtcbiAgICAgICAgdmFyIGJkeW5hbWljcyA9IHJlZiQxWzFdO1xuICAgICAgICB2YXIgYnN0YXJzID0gcmVmJDFbMl07XG4gICAgICAgIGlmIChhc3RhcnMgIT09IGJzdGFycykge1xuICAgICAgICAgICAgcmV0dXJuIGFzdGFycyAtIGJzdGFycztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXN0YXJzKSB7XG4gICAgICAgICAgICBpZiAoYXN0YXRpY3MgIT09IGJzdGF0aWNzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJzdGF0aWNzIC0gYXN0YXRpY3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWR5bmFtaWNzICE9PSBiZHluYW1pY3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmR5bmFtaWNzIC0gYWR5bmFtaWNzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhZHluYW1pY3MgIT09IGJkeW5hbWljcykge1xuICAgICAgICAgICAgcmV0dXJuIGFkeW5hbWljcyAtIGJkeW5hbWljcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXN0YXRpY3MgIT09IGJzdGF0aWNzKSB7XG4gICAgICAgICAgICByZXR1cm4gYnN0YXRpY3MgLSBhc3RhdGljcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHJlY29nbml6ZUNoYXIoc3RhdGVzLCBjaCkge1xuICAgIHZhciBuZXh0U3RhdGVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdGF0ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHN0YXRlc1tpXTtcbiAgICAgICAgbmV4dFN0YXRlcyA9IG5leHRTdGF0ZXMuY29uY2F0KHN0YXRlLm1hdGNoKGNoKSk7XG4gICAgfVxuICAgIHJldHVybiBuZXh0U3RhdGVzO1xufVxudmFyIFJlY29nbml6ZVJlc3VsdHMgPSBmdW5jdGlvbiBSZWNvZ25pemVSZXN1bHRzKHF1ZXJ5UGFyYW1zKSB7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICAgIHRoaXMucXVlcnlQYXJhbXMgPSBxdWVyeVBhcmFtcyB8fCB7fTtcbn07XG5cblJlY29nbml6ZVJlc3VsdHMucHJvdG90eXBlLnNwbGljZSA9IEFycmF5LnByb3RvdHlwZS5zcGxpY2U7XG5SZWNvZ25pemVSZXN1bHRzLnByb3RvdHlwZS5zbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblJlY29nbml6ZVJlc3VsdHMucHJvdG90eXBlLnB1c2ggPSBBcnJheS5wcm90b3R5cGUucHVzaDtcbmZ1bmN0aW9uIGZpbmRIYW5kbGVyKHN0YXRlLCBvcmlnaW5hbFBhdGgsIHF1ZXJ5UGFyYW1zKSB7XG4gICAgdmFyIGhhbmRsZXJzID0gc3RhdGUuaGFuZGxlcnM7XG4gICAgdmFyIHJlZ2V4ID0gc3RhdGUucmVnZXgoKTtcbiAgICBpZiAoIXJlZ2V4IHx8ICFoYW5kbGVycylcbiAgICAgICAgeyB0aHJvdyBuZXcgRXJyb3IoXCJzdGF0ZSBub3QgaW5pdGlhbGl6ZWRcIik7IH1cbiAgICB2YXIgY2FwdHVyZXMgPSBvcmlnaW5hbFBhdGgubWF0Y2gocmVnZXgpO1xuICAgIHZhciBjdXJyZW50Q2FwdHVyZSA9IDE7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBSZWNvZ25pemVSZXN1bHRzKHF1ZXJ5UGFyYW1zKTtcbiAgICByZXN1bHQubGVuZ3RoID0gaGFuZGxlcnMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSBoYW5kbGVyc1tpXTtcbiAgICAgICAgdmFyIG5hbWVzID0gaGFuZGxlci5uYW1lcztcbiAgICAgICAgdmFyIHNob3VsZERlY29kZXMgPSBoYW5kbGVyLnNob3VsZERlY29kZXM7XG4gICAgICAgIHZhciBwYXJhbXMgPSBFbXB0eU9iamVjdDtcbiAgICAgICAgdmFyIGlzRHluYW1pYyA9IGZhbHNlO1xuICAgICAgICBpZiAobmFtZXMgIT09IEVtcHR5QXJyYXkgJiYgc2hvdWxkRGVjb2RlcyAhPT0gRW1wdHlBcnJheSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBuYW1lcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGlzRHluYW1pYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBuYW1lc1tqXTtcbiAgICAgICAgICAgICAgICB2YXIgY2FwdHVyZSA9IGNhcHR1cmVzICYmIGNhcHR1cmVzW2N1cnJlbnRDYXB0dXJlKytdO1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMgPT09IEVtcHR5T2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoUm91dGVSZWNvZ25pemVyLkVOQ09ERV9BTkRfREVDT0RFX1BBVEhfU0VHTUVOVFMgJiYgc2hvdWxkRGVjb2Rlc1tqXSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXNbbmFtZV0gPSBjYXB0dXJlICYmIGRlY29kZVVSSUNvbXBvbmVudChjYXB0dXJlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtc1tuYW1lXSA9IGNhcHR1cmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFtpXSA9IHtcbiAgICAgICAgICAgIGhhbmRsZXI6IGhhbmRsZXIuaGFuZGxlcixcbiAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICAgICAgaXNEeW5hbWljOiBpc0R5bmFtaWNcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGRlY29kZVF1ZXJ5UGFyYW1QYXJ0KHBhcnQpIHtcbiAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNDAxL2ludGVyYWN0L2Zvcm1zLmh0bWwjaC0xNy4xMy40LjFcbiAgICBwYXJ0ID0gcGFydC5yZXBsYWNlKC9cXCsvZ20sIFwiJTIwXCIpO1xuICAgIHZhciByZXN1bHQ7XG4gICAgdHJ5IHtcbiAgICAgICAgcmVzdWx0ID0gZGVjb2RlVVJJQ29tcG9uZW50KHBhcnQpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmVzdWx0ID0gXCJcIjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbnZhciBSb3V0ZVJlY29nbml6ZXIgPSBmdW5jdGlvbiBSb3V0ZVJlY29nbml6ZXIoKSB7XG4gICAgdGhpcy5uYW1lcyA9IGNyZWF0ZU1hcCgpO1xuICAgIHZhciBzdGF0ZXMgPSBbXTtcbiAgICB2YXIgc3RhdGUgPSBuZXcgU3RhdGUoc3RhdGVzLCAwLCAtMSAvKiBBTlkgKi8sIHRydWUsIGZhbHNlKTtcbiAgICBzdGF0ZXNbMF0gPSBzdGF0ZTtcbiAgICB0aGlzLnN0YXRlcyA9IHN0YXRlcztcbiAgICB0aGlzLnJvb3RTdGF0ZSA9IHN0YXRlO1xufTtcblJvdXRlUmVjb2duaXplci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChyb3V0ZXMsIG9wdGlvbnMpIHtcbiAgICB2YXIgY3VycmVudFN0YXRlID0gdGhpcy5yb290U3RhdGU7XG4gICAgdmFyIHBhdHRlcm4gPSBcIl5cIjtcbiAgICB2YXIgdHlwZXMgPSBbMCwgMCwgMF07XG4gICAgdmFyIGhhbmRsZXJzID0gbmV3IEFycmF5KHJvdXRlcy5sZW5ndGgpO1xuICAgIHZhciBhbGxTZWdtZW50cyA9IFtdO1xuICAgIHZhciBpc0VtcHR5ID0gdHJ1ZTtcbiAgICB2YXIgaiA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3V0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHJvdXRlID0gcm91dGVzW2ldO1xuICAgICAgICB2YXIgcmVmID0gcGFyc2UoYWxsU2VnbWVudHMsIHJvdXRlLnBhdGgsIHR5cGVzKTtcbiAgICAgICAgICAgIHZhciBuYW1lcyA9IHJlZi5uYW1lcztcbiAgICAgICAgICAgIHZhciBzaG91bGREZWNvZGVzID0gcmVmLnNob3VsZERlY29kZXM7XG4gICAgICAgIC8vIHByZXNlcnZlIGogc28gaXQgcG9pbnRzIHRvIHRoZSBzdGFydCBvZiBuZXdseSBhZGRlZCBzZWdtZW50c1xuICAgICAgICBmb3IgKDsgaiA8IGFsbFNlZ21lbnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgc2VnbWVudCA9IGFsbFNlZ21lbnRzW2pdO1xuICAgICAgICAgICAgaWYgKHNlZ21lbnQudHlwZSA9PT0gNCAvKiBFcHNpbG9uICovKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpc0VtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBBZGQgYSBcIi9cIiBmb3IgdGhlIG5ldyBzZWdtZW50XG4gICAgICAgICAgICBjdXJyZW50U3RhdGUgPSBjdXJyZW50U3RhdGUucHV0KDQ3IC8qIFNMQVNIICovLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICAgICAgcGF0dGVybiArPSBcIi9cIjtcbiAgICAgICAgICAgIC8vIEFkZCBhIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBzZWdtZW50IHRvIHRoZSBORkEgYW5kIHJlZ2V4XG4gICAgICAgICAgICBjdXJyZW50U3RhdGUgPSBlYWNoQ2hhcltzZWdtZW50LnR5cGVdKHNlZ21lbnQsIGN1cnJlbnRTdGF0ZSk7XG4gICAgICAgICAgICBwYXR0ZXJuICs9IHJlZ2V4W3NlZ21lbnQudHlwZV0oc2VnbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlcnNbaV0gPSB7XG4gICAgICAgICAgICBoYW5kbGVyOiByb3V0ZS5oYW5kbGVyLFxuICAgICAgICAgICAgbmFtZXM6IG5hbWVzLFxuICAgICAgICAgICAgc2hvdWxkRGVjb2Rlczogc2hvdWxkRGVjb2Rlc1xuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoaXNFbXB0eSkge1xuICAgICAgICBjdXJyZW50U3RhdGUgPSBjdXJyZW50U3RhdGUucHV0KDQ3IC8qIFNMQVNIICovLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICBwYXR0ZXJuICs9IFwiL1wiO1xuICAgIH1cbiAgICBjdXJyZW50U3RhdGUuaGFuZGxlcnMgPSBoYW5kbGVycztcbiAgICBjdXJyZW50U3RhdGUucGF0dGVybiA9IHBhdHRlcm4gKyBcIiRcIjtcbiAgICBjdXJyZW50U3RhdGUudHlwZXMgPSB0eXBlcztcbiAgICB2YXIgbmFtZTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwib2JqZWN0XCIgJiYgb3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zLmFzKSB7XG4gICAgICAgIG5hbWUgPSBvcHRpb25zLmFzO1xuICAgIH1cbiAgICBpZiAobmFtZSkge1xuICAgICAgICAvLyBpZiAodGhpcy5uYW1lc1tuYW1lXSkge1xuICAgICAgICAvLyAgIHRocm93IG5ldyBFcnJvcihcIllvdSBtYXkgbm90IGFkZCBhIGR1cGxpY2F0ZSByb3V0ZSBuYW1lZCBgXCIgKyBuYW1lICsgXCJgLlwiKTtcbiAgICAgICAgLy8gfVxuICAgICAgICB0aGlzLm5hbWVzW25hbWVdID0ge1xuICAgICAgICAgICAgc2VnbWVudHM6IGFsbFNlZ21lbnRzLFxuICAgICAgICAgICAgaGFuZGxlcnM6IGhhbmRsZXJzXG4gICAgICAgIH07XG4gICAgfVxufTtcblJvdXRlUmVjb2duaXplci5wcm90b3R5cGUuaGFuZGxlcnNGb3IgPSBmdW5jdGlvbiBoYW5kbGVyc0ZvciAobmFtZSkge1xuICAgIHZhciByb3V0ZSA9IHRoaXMubmFtZXNbbmFtZV07XG4gICAgaWYgKCFyb3V0ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGVyZSBpcyBubyByb3V0ZSBuYW1lZCBcIiArIG5hbWUpO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KHJvdXRlLmhhbmRsZXJzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3V0ZS5oYW5kbGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaGFuZGxlciA9IHJvdXRlLmhhbmRsZXJzW2ldO1xuICAgICAgICByZXN1bHRbaV0gPSBoYW5kbGVyO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblJvdXRlUmVjb2duaXplci5wcm90b3R5cGUuaGFzUm91dGUgPSBmdW5jdGlvbiBoYXNSb3V0ZSAobmFtZSkge1xuICAgIHJldHVybiAhIXRoaXMubmFtZXNbbmFtZV07XG59O1xuUm91dGVSZWNvZ25pemVyLnByb3RvdHlwZS5nZW5lcmF0ZSA9IGZ1bmN0aW9uIGdlbmVyYXRlJDEgKG5hbWUsIHBhcmFtcykge1xuICAgIHZhciByb3V0ZSA9IHRoaXMubmFtZXNbbmFtZV07XG4gICAgdmFyIG91dHB1dCA9IFwiXCI7XG4gICAgaWYgKCFyb3V0ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGVyZSBpcyBubyByb3V0ZSBuYW1lZCBcIiArIG5hbWUpO1xuICAgIH1cbiAgICB2YXIgc2VnbWVudHMgPSByb3V0ZS5zZWdtZW50cztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgICAgIGlmIChzZWdtZW50LnR5cGUgPT09IDQgLyogRXBzaWxvbiAqLykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0ICs9IFwiL1wiO1xuICAgICAgICBvdXRwdXQgKz0gZ2VuZXJhdGVbc2VnbWVudC50eXBlXShzZWdtZW50LCBwYXJhbXMpO1xuICAgIH1cbiAgICBpZiAob3V0cHV0LmNoYXJBdCgwKSAhPT0gXCIvXCIpIHtcbiAgICAgICAgb3V0cHV0ID0gXCIvXCIgKyBvdXRwdXQ7XG4gICAgfVxuICAgIGlmIChwYXJhbXMgJiYgcGFyYW1zLnF1ZXJ5UGFyYW1zKSB7XG4gICAgICAgIG91dHB1dCArPSB0aGlzLmdlbmVyYXRlUXVlcnlTdHJpbmcocGFyYW1zLnF1ZXJ5UGFyYW1zKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbn07XG5Sb3V0ZVJlY29nbml6ZXIucHJvdG90eXBlLmdlbmVyYXRlUXVlcnlTdHJpbmcgPSBmdW5jdGlvbiBnZW5lcmF0ZVF1ZXJ5U3RyaW5nIChwYXJhbXMpIHtcbiAgICB2YXIgcGFpcnMgPSBbXTtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHBhcmFtcyk7XG4gICAga2V5cy5zb3J0KCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICB2YXIgdmFsdWUgPSBwYXJhbXNba2V5XTtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYWlyID0gZW5jb2RlVVJJQ29tcG9uZW50KGtleSk7XG4gICAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWx1ZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHZhciBhcnJheVBhaXIgPSBrZXkgKyBcIltdXCIgKyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZVtqXSk7XG4gICAgICAgICAgICAgICAgcGFpcnMucHVzaChhcnJheVBhaXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFpciArPSBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG4gICAgICAgICAgICBwYWlycy5wdXNoKHBhaXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwYWlycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIHJldHVybiBcIj9cIiArIHBhaXJzLmpvaW4oXCImXCIpO1xufTtcblJvdXRlUmVjb2duaXplci5wcm90b3R5cGUucGFyc2VRdWVyeVN0cmluZyA9IGZ1bmN0aW9uIHBhcnNlUXVlcnlTdHJpbmcgKHF1ZXJ5U3RyaW5nKSB7XG4gICAgdmFyIHBhaXJzID0gcXVlcnlTdHJpbmcuc3BsaXQoXCImXCIpO1xuICAgIHZhciBxdWVyeVBhcmFtcyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFpcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHBhaXIgPSBwYWlyc1tpXS5zcGxpdChcIj1cIiksIGtleSA9IGRlY29kZVF1ZXJ5UGFyYW1QYXJ0KHBhaXJbMF0pLCBrZXlMZW5ndGggPSBrZXkubGVuZ3RoLCBpc0FycmF5ID0gZmFsc2UsIHZhbHVlID0gKHZvaWQgMCk7XG4gICAgICAgIGlmIChwYWlyLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdmFsdWUgPSBcInRydWVcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSBhcnJheXNcbiAgICAgICAgICAgIGlmIChrZXlMZW5ndGggPiAyICYmIGtleS5zbGljZShrZXlMZW5ndGggLSAyKSA9PT0gXCJbXVwiKSB7XG4gICAgICAgICAgICAgICAgaXNBcnJheSA9IHRydWU7XG4gICAgICAgICAgICAgICAga2V5ID0ga2V5LnNsaWNlKDAsIGtleUxlbmd0aCAtIDIpO1xuICAgICAgICAgICAgICAgIGlmICghcXVlcnlQYXJhbXNba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICBxdWVyeVBhcmFtc1trZXldID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWUgPSBwYWlyWzFdID8gZGVjb2RlUXVlcnlQYXJhbVBhcnQocGFpclsxXSkgOiBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0FycmF5KSB7XG4gICAgICAgICAgICBxdWVyeVBhcmFtc1trZXldLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcXVlcnlQYXJhbXNba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBxdWVyeVBhcmFtcztcbn07XG5Sb3V0ZVJlY29nbml6ZXIucHJvdG90eXBlLnJlY29nbml6ZSA9IGZ1bmN0aW9uIHJlY29nbml6ZSAocGF0aCkge1xuICAgIHZhciByZXN1bHRzO1xuICAgIHZhciBzdGF0ZXMgPSBbdGhpcy5yb290U3RhdGVdO1xuICAgIHZhciBxdWVyeVBhcmFtcyA9IHt9O1xuICAgIHZhciBpc1NsYXNoRHJvcHBlZCA9IGZhbHNlO1xuICAgIHZhciBoYXNoU3RhcnQgPSBwYXRoLmluZGV4T2YoXCIjXCIpO1xuICAgIGlmIChoYXNoU3RhcnQgIT09IC0xKSB7XG4gICAgICAgIHBhdGggPSBwYXRoLnN1YnN0cigwLCBoYXNoU3RhcnQpO1xuICAgIH1cbiAgICB2YXIgcXVlcnlTdGFydCA9IHBhdGguaW5kZXhPZihcIj9cIik7XG4gICAgaWYgKHF1ZXJ5U3RhcnQgIT09IC0xKSB7XG4gICAgICAgIHZhciBxdWVyeVN0cmluZyA9IHBhdGguc3Vic3RyKHF1ZXJ5U3RhcnQgKyAxLCBwYXRoLmxlbmd0aCk7XG4gICAgICAgIHBhdGggPSBwYXRoLnN1YnN0cigwLCBxdWVyeVN0YXJ0KTtcbiAgICAgICAgcXVlcnlQYXJhbXMgPSB0aGlzLnBhcnNlUXVlcnlTdHJpbmcocXVlcnlTdHJpbmcpO1xuICAgIH1cbiAgICBpZiAocGF0aC5jaGFyQXQoMCkgIT09IFwiL1wiKSB7XG4gICAgICAgIHBhdGggPSBcIi9cIiArIHBhdGg7XG4gICAgfVxuICAgIHZhciBvcmlnaW5hbFBhdGggPSBwYXRoO1xuICAgIGlmIChSb3V0ZVJlY29nbml6ZXIuRU5DT0RFX0FORF9ERUNPREVfUEFUSF9TRUdNRU5UUykge1xuICAgICAgICBwYXRoID0gbm9ybWFsaXplUGF0aChwYXRoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHBhdGggPSBkZWNvZGVVUkkocGF0aCk7XG4gICAgICAgIG9yaWdpbmFsUGF0aCA9IGRlY29kZVVSSShvcmlnaW5hbFBhdGgpO1xuICAgIH1cbiAgICB2YXIgcGF0aExlbiA9IHBhdGgubGVuZ3RoO1xuICAgIGlmIChwYXRoTGVuID4gMSAmJiBwYXRoLmNoYXJBdChwYXRoTGVuIC0gMSkgPT09IFwiL1wiKSB7XG4gICAgICAgIHBhdGggPSBwYXRoLnN1YnN0cigwLCBwYXRoTGVuIC0gMSk7XG4gICAgICAgIG9yaWdpbmFsUGF0aCA9IG9yaWdpbmFsUGF0aC5zdWJzdHIoMCwgb3JpZ2luYWxQYXRoLmxlbmd0aCAtIDEpO1xuICAgICAgICBpc1NsYXNoRHJvcHBlZCA9IHRydWU7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICBzdGF0ZXMgPSByZWNvZ25pemVDaGFyKHN0YXRlcywgcGF0aC5jaGFyQ29kZUF0KGkpKTtcbiAgICAgICAgaWYgKCFzdGF0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgc29sdXRpb25zID0gW107XG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgc3RhdGVzLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgaWYgKHN0YXRlc1tpJDFdLmhhbmRsZXJzKSB7XG4gICAgICAgICAgICBzb2x1dGlvbnMucHVzaChzdGF0ZXNbaSQxXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGVzID0gc29ydFNvbHV0aW9ucyhzb2x1dGlvbnMpO1xuICAgIHZhciBzdGF0ZSA9IHNvbHV0aW9uc1swXTtcbiAgICBpZiAoc3RhdGUgJiYgc3RhdGUuaGFuZGxlcnMpIHtcbiAgICAgICAgLy8gaWYgYSB0cmFpbGluZyBzbGFzaCB3YXMgZHJvcHBlZCBhbmQgYSBzdGFyIHNlZ21lbnQgaXMgdGhlIGxhc3Qgc2VnbWVudFxuICAgICAgICAvLyBzcGVjaWZpZWQsIHB1dCB0aGUgdHJhaWxpbmcgc2xhc2ggYmFja1xuICAgICAgICBpZiAoaXNTbGFzaERyb3BwZWQgJiYgc3RhdGUucGF0dGVybiAmJiBzdGF0ZS5wYXR0ZXJuLnNsaWNlKC01KSA9PT0gXCIoLispJFwiKSB7XG4gICAgICAgICAgICBvcmlnaW5hbFBhdGggPSBvcmlnaW5hbFBhdGggKyBcIi9cIjtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRzID0gZmluZEhhbmRsZXIoc3RhdGUsIG9yaWdpbmFsUGF0aCwgcXVlcnlQYXJhbXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbn07XG5Sb3V0ZVJlY29nbml6ZXIuVkVSU0lPTiA9IFwiMC4zLjRcIjtcbi8vIFNldCB0byBmYWxzZSB0byBvcHQtb3V0IG9mIGVuY29kaW5nIGFuZCBkZWNvZGluZyBwYXRoIHNlZ21lbnRzLlxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90aWxkZWlvL3JvdXRlLXJlY29nbml6ZXIvcHVsbC81NVxuUm91dGVSZWNvZ25pemVyLkVOQ09ERV9BTkRfREVDT0RFX1BBVEhfU0VHTUVOVFMgPSB0cnVlO1xuUm91dGVSZWNvZ25pemVyLk5vcm1hbGl6ZXIgPSB7XG4gICAgbm9ybWFsaXplU2VnbWVudDogbm9ybWFsaXplU2VnbWVudCwgbm9ybWFsaXplUGF0aDogbm9ybWFsaXplUGF0aCwgZW5jb2RlUGF0aFNlZ21lbnQ6IGVuY29kZVBhdGhTZWdtZW50XG59O1xuUm91dGVSZWNvZ25pemVyLnByb3RvdHlwZS5tYXAgPSBtYXA7XG5cbmV4cG9ydCBkZWZhdWx0IFJvdXRlUmVjb2duaXplcjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm91dGUtcmVjb2duaXplci5lcy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/route-recognizer/dist/route-recognizer.es.js\n");

/***/ })

};
;